---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: sa-r3api-dummy
  namespace: default
automountServiceAccountToken: true
---

apiVersion: v1
kind: Secret
metadata:
  name: secret-k2hr3-ca-dummy
  namespace: default
type: Opaque
data:


---

apiVersion: v1
kind: ConfigMap
metadata:
  name: configmap-k2hr3-dummy
data:
  k2hr3-k2hdkc-serverproc-wrap.sh: |-
    #!/bin/sh
    #
    # K2HR3 Helm Chart
    #
    # Copyright 2022 Yahoo Japan Corporation.
    #
    # K2HR3 is K2hdkc based Resource and Roles and policy Rules, gathers 
    # common management information for the cloud.
    # K2HR3 can dynamically manage information as "who", "what", "operate".
    # These are stored as roles, resources, policies in K2hdkc, and the
    # client system can dynamically read and modify these information.
    #
    # For the full copyright and license information, please view
    # the license file that was distributed with this source code.
    #
    # AUTHOR:   Takeshi Nakatani
    # CREATE:   Wed Jan 19 2022
    # REVISION:
    #
    
    #----------------------------------------------------------
    # Common variables
    #----------------------------------------------------------
    PRGNAME=$(basename "$0")
    SCRIPTDIR=$(dirname "$0")
    SCRIPTDIR=$(cd "${SCRIPTDIR}" || exit 1; pwd)
    
    ANTPICKAX_ETC_DIR="/etc/antpickax"
    ANTPICKAX_RUN_DIR="/var/run/antpickax"
    
    WATCHER_SERVICEIN_FILE="k2hkdc_servicein.cmd"
    WATCHER_SERVICEIN_FILE_PATH="${ANTPICKAX_RUN_DIR}/${WATCHER_SERVICEIN_FILE}"
    WATCHER_RECOVER_FILE="k2hkdc_recover.cmd"
    WATCHER_RECOVER_FILE_PATH="${ANTPICKAX_RUN_DIR}/${WATCHER_RECOVER_FILE}"
    WATCHER_STSUPDATE_FILE="k2hkdc_statusupdate.cmd"
    WATCHER_STSUPDATE_FILE_PATH="${ANTPICKAX_RUN_DIR}/${WATCHER_STSUPDATE_FILE}"
    
    WATCHER_OPT="-watcher"
    RETRYCOUNT=60
    FILE_RETRYCOUNT=60
    SLEEP_LONG=20
    SLEEP_MIDDLE=10
    SLEEP_SHORT=1
    
    #----------------------------------------------------------
    # Make configuration file path
    #----------------------------------------------------------
    #
    # Always k2hdkc process is on server node, if not specified mode.
    #
    K2HDDKC_MODE="server"
    INI_FILE="${K2HDDKC_MODE}.ini"
    INI_FILE_PATH="${ANTPICKAX_ETC_DIR}/${INI_FILE}"
    
    #----------------------------------------------------------
    # Wait configuration file creation
    #----------------------------------------------------------
    FILE_EXISTS=0
    while [ "${FILE_EXISTS}" -eq 0 ]; do
    	if [ -f "${INI_FILE_PATH}" ]; then
    		FILE_EXISTS=1
    	else
    		FILE_RETRYCOUNT=$((FILE_RETRYCOUNT - 1))
    		if [ "${FILE_RETRYCOUNT}" -le 0 ]; then
    			echo "[ERROR] ${INI_FILE_PATH} is not existed."
    			exit 1
    		fi
    		sleep "${SLEEP_SHORT}"
    	fi
    done
    
    #----------------------------------------------------------
    # Main processing
    #----------------------------------------------------------
    if [ -n "$1" ] && [ "$1" = "${WATCHER_OPT}" ]; then
    	#
    	# Run watcher
    	#
    	LOCALHOSTNAME=$(chmpxstatus -conf "${INI_FILE_PATH}" -self	| grep 'hostname'		| sed -e 's/[[:space:]]*$//g' -e 's/^[[:space:]]*hostname[[:space:]]*=[[:space:]]*//g')
    	CTLPORT=$(chmpxstatus -conf "${INI_FILE_PATH}" -self		| grep 'control port'	| sed -e 's/[[:space:]]*$//g' -e 's/^[[:space:]]*control port[[:space:]]*=[[:space:]]*//g')
    	CUK=$(chmpxstatus -conf "${INI_FILE_PATH}" -self			| grep 'cuk'			| sed -e 's/[[:space:]]*$//g' -e 's/^[[:space:]]*cuk[[:space:]]*=[[:space:]]*//g')
    	CUSTOM_SEED=$(chmpxstatus -conf "${INI_FILE_PATH}" -self	| grep 'custom id seed'	| sed -e 's/[[:space:]]*$//g' -e 's/^[[:space:]]*custom id seed[[:space:]]*=[[:space:]]*//g')
    
    	{
    		echo "servicein ${LOCALHOSTNAME}:${CTLPORT}:${CUK}:${CUSTOM_SEED}:"
    		echo "sleep ${SLEEP_SHORT}"
    		echo "statusupdate"
    		echo "exit"
    	} > "${WATCHER_SERVICEIN_FILE_PATH}"
    	{
    		echo "serviceout ${LOCALHOSTNAME}:${CTLPORT}:${CUK}:${CUSTOM_SEED}:"
    		echo "sleep ${SLEEP_SHORT}"
    		echo "statusupdate"
    		echo "exit"
    	} > "${WATCHER_RECOVER_FILE_PATH}"
    	{
    		echo "statusupdate"
    		echo "exit"
    	} > ${WATCHER_STSUPDATE_FILE_PATH}
    
    	LOOP_BREAK=0
    	while [ "${LOOP_BREAK}" -eq 0 ]; do
    		if chmpxstatus -conf "${INI_FILE_PATH}" -self -wait -live up -ring servicein -nosuspend -timeout "${SLEEP_SHORT}" >/dev/null 2>&1; then
    			if chmpxstatus -conf "${INI_FILE_PATH}" -self | grep 'status[[:space:]]*=' | grep '\[ADD\]' | grep '\[Pending\]' >/dev/null 2>&1; then
    				# 
    				# When the status is "ADD:Pending", type a new ServiceIn command after short sleep.
    				#
    				sleep ${SLEEP_MIDDLE}
    				if chmpxstatus -conf "${INI_FILE_PATH}" -self | grep 'status[[:space:]]*=' | grep '\[ADD\]' | grep '\[Pending\]' >/dev/null 2>&1; then
    					#
    					# To Service Out
    					#
    					chmpxlinetool -conf "${INI_FILE_PATH}" -run "${WATCHER_RECOVER_FILE_PATH}" >/dev/null 2>&1
    				fi
    				sleep "${SLEEP_MIDDLE}"
    			else
    				sleep "${SLEEP_LONG}"
    				chmpxlinetool -conf "${INI_FILE_PATH}" -run "${WATCHER_STSUPDATE_FILE_PATH}" >/dev/null 2>&1
    			fi
    		else
    			if chmpxstatus -conf "${INI_FILE_PATH}" -self -wait -live up -ring serviceout -nosuspend -timeout "${SLEEP_SHORT}" >/dev/null 2>&1; then
    				# 
    				# When the status is "ServiceOut:NoSuspend", type a new ServiceIn command after short sleep.
    				#
    				sleep "${SLEEP_MIDDLE}"
    				if chmpxstatus -conf "${INI_FILE_PATH}" -self -wait -live up -ring serviceout -nosuspend -timeout "${SLEEP_SHORT}" >/dev/null 2>&1; then
    					#
    					# To Service In
    					#
    					chmpxlinetool -conf "${INI_FILE_PATH}" -run "${WATCHER_SERVICEIN_FILE_PATH}" >/dev/null 2>&1
    				else
    					chmpxlinetool -conf "${INI_FILE_PATH}" -run "${WATCHER_STSUPDATE_FILE_PATH}" >/dev/null 2>&1
    				fi
    			fi
    			sleep "${SLEEP_MIDDLE}"
    		fi
    	done
    
    else
    	#
    	# Run k2hdkc
    	#
    	CHMPX_UP=0
    	while [ "${CHMPX_UP}" -eq 0 ]; do
    		#
    		# Check keep status while SLEEP_LONG second
    		#
    		STATUS_KEEP_TIME="${SLEEP_LONG}"
    		while [ "${STATUS_KEEP_TIME}" -gt 0 ]; do
    			if ! chmpxstatus -conf "${INI_FILE_PATH}" -self -wait -live up -ring serviceout -suspend -timeout "${SLEEP_SHORT}" >/dev/null 2>&1; then
    				if ! chmpxstatus -conf "${INI_FILE_PATH}" -self -wait -live up -ring servicein -suspend -timeout "${SLEEP_SHORT}" >/dev/null 2>&1; then
    					break;
    				fi
    			fi
    			sleep "${SLEEP_SHORT}"
    			STATUS_KEEP_TIME=$((STATUS_KEEP_TIME - SLEEP_SHORT))
    		done
    
    		if [ "${STATUS_KEEP_TIME}" -le 0 ]; then
    			CHMPX_UP=1
    		else
    			sleep "${SLEEP_MIDDLE}"
    			RETRYCOUNT=$((RETRYCOUNT - 1))
    			if [ "${RETRYCOUNT}" -le 0 ]; then
    				break;
    			fi
    		fi
    	done
    
    	if [ "${CHMPX_UP}" -eq 0 ]; then
    		exit 1
    	fi
    
    	#
    	# Run checker process
    	#
    	/bin/sh "${SCRIPTDIR}/${PRGNAME}" "${WATCHER_OPT}" >/dev/null 2>&1 <&- &
    
    	set -e
    
    	K2HFILE=$(grep K2HFILE "${INI_FILE_PATH}" | sed -e 's/=//g' -e 's/K2HFILE//g' -e 's/^[[:space:]]*//g' -e 's/[[:space:]]*$//g')
    	K2HDIR=$(dirname "${K2HFILE}")
    	mkdir -p "${K2HDIR}"
    
    	#
    	# stdio/stderr is not redirected.
    	#
    	k2hdkc -conf "${INI_FILE_PATH}" -d err
    fi
    
    exit $?
    
    #
    # Local variables:
    # tab-width: 4
    # c-basic-offset: 4
    # End:
    # vim600: noexpandtab sw=4 ts=4 fdm=marker
    # vim<600: noexpandtab sw=4 ts=4
    #
    
  k2hr3-k2hdkc-chmpxproc-wrap.sh: |-
    #!/bin/sh
    #
    # K2HR3 Helm Chart
    #
    # Copyright 2022 Yahoo Japan Corporation.
    #
    # K2HR3 is K2hdkc based Resource and Roles and policy Rules, gathers 
    # common management information for the cloud.
    # K2HR3 can dynamically manage information as "who", "what", "operate".
    # These are stored as roles, resources, policies in K2hdkc, and the
    # client system can dynamically read and modify these information.
    #
    # For the full copyright and license information, please view
    # the license file that was distributed with this source code.
    #
    # AUTHOR:   Takeshi Nakatani
    # CREATE:   Wed Jan 19 2022
    # REVISION:
    #
    
    #----------------------------------------------------------
    # Common variables
    #----------------------------------------------------------
    ANTPICKAX_ETC_DIR="/etc/antpickax"
    FILE_RETRYCOUNT=60
    LOOKUP_RETRYCOUNT=60
    SLEEP_SHORT=10
    
    #----------------------------------------------------------
    # Configuration file path
    #----------------------------------------------------------
    if [ -z "$1" ] || [ "$1" = "SERVER" ] || [ "$1" = "server" ]; then
    	CHMPX_MODE="server"
    	SLEEP_GAP=10
    elif [ "$1" = "SLAVE" ] || [ "$1" = "slave" ]; then
    	CHMPX_MODE="slave"
    	SLEEP_GAP=30
    else
    	CHMPX_MODE="server"
    	SLEEP_GAP=10
    fi
    INI_FILE="${CHMPX_MODE}.ini"
    INI_FILE_PATH="${ANTPICKAX_ETC_DIR}/${INI_FILE}"
    
    #----------------------------------------------------------
    # Wait configuration file creation
    #----------------------------------------------------------
    FILE_EXISTS=0
    while [ "${FILE_EXISTS}" -eq 0 ]; do
    	if [ -f "${INI_FILE_PATH}" ]; then
    		FILE_EXISTS=1
    	else
    		FILE_RETRYCOUNT=$((FILE_RETRYCOUNT - 1))
    		if [ "${FILE_RETRYCOUNT}" -le 0 ]; then
    			echo "[ERROR] ${INI_FILE_PATH} is not existed."
    			exit 1
    		fi
    		sleep "${SLEEP_SHORT}"
    	fi
    done
    
    #----------------------------------------------------------
    # Setup OS_NAME
    #----------------------------------------------------------
    if [ ! -f /etc/os-release ]; then
    	echo "[ERROR] Not found /etc/os-release file."
    	exit 1
    fi
    OS_NAME=$(grep '^ID[[:space:]]*=[[:space:]]*' /etc/os-release | sed -e 's|^ID[[:space:]]*=[[:space:]]*||g' -e 's|^[[:space:]]*||g' -e 's|[[:space:]]*$||g' -e 's|"||g')
    
    if echo "${OS_NAME}" | grep -q -i "centos"; then
    	echo "[ERROR] Not support ${OS_NAME}."
    	exit 1
    fi
    
    #----------------------------------------------------------
    # Utility for ubuntu
    #----------------------------------------------------------
    IS_SETUP_APT_ENV=0
    
    setup_apt_envirnment()
    {
    	if [ "${IS_SETUP_APT_ENV}" -eq 1 ]; then
    		return 0
    	fi
    	if [ -n "${HTTP_PROXY}" ] || [ -n "${http_proxy}" ] || [ -n "${HTTPS_PROXY}" ] || [ -n "${https_proxy}" ]; then
    		if [ ! -f /etc/apt/apt.conf.d/00-aptproxy.conf ] || ! grep -q -e 'Acquire::http::Proxy' -e 'Acquire::https::Proxy' /etc/apt/apt.conf.d/00-aptproxy.conf; then
    			_FOUND_HTTP_PROXY=$(if [ -n "${HTTP_PROXY}" ]; then echo "${HTTP_PROXY}"; elif [ -n "${http_proxy}" ]; then echo "${http_proxy}"; else echo ''; fi)
    			_FOUND_HTTPS_PROXY=$(if [ -n "${HTTPS_PROXY}" ]; then echo "${HTTPS_PROXY}"; elif [ -n "${https_proxy}" ]; then echo "${https_proxy}"; else echo ''; fi)
    
    			if [ -n "${_FOUND_HTTP_PROXY}" ] && echo "${_FOUND_HTTP_PROXY}" | grep -q -v '://'; then
    				_FOUND_HTTP_PROXY="http://${_FOUND_HTTP_PROXY}"
    			fi
    			if [ -n "${_FOUND_HTTPS_PROXY}" ] && echo "${_FOUND_HTTPS_PROXY}" | grep -q -v '://'; then
    				_FOUND_HTTPS_PROXY="http://${_FOUND_HTTPS_PROXY}"
    			fi
    			if [ ! -d /etc/apt/apt.conf.d ]; then
    				mkdir -p /etc/apt/apt.conf.d
    			fi
    			{
    				if [ -n "${_FOUND_HTTP_PROXY}" ]; then
    					echo "Acquire::http::Proxy \"${_FOUND_HTTP_PROXY}\";"
    				fi
    				if [ -n "${_FOUND_HTTPS_PROXY}" ]; then
    					echo "Acquire::https::Proxy \"${_FOUND_HTTPS_PROXY}\";"
    				fi
    			} >> /etc/apt/apt.conf.d/00-aptproxy.conf
    		fi
    	fi
    	DEBIAN_FRONTEND=noninteractive
    	export DEBIAN_FRONTEND
    
    	IS_SETUP_APT_ENV=1
    
    	return 0
    }
    
    #----------------------------------------------------------
    # Preparation
    #----------------------------------------------------------
    #
    # Check and Install nslookup
    #
    if ! command -v nslookup >/dev/null 2>&1; then
    	if echo "${OS_NAME}" | grep -q -i "alpine"; then
    		if ! apk update -q --no-progress >/dev/null 2>&1 || ! apk add -q --no-progress --no-cache bind-tools >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install bind-tools(nslookup)."
    			exit 1
    		fi
    	elif echo "${OS_NAME}" | grep -q -i -e "ubuntu" -e "debian"; then
    		setup_apt_envirnment
    		if ! apt-get update -y -q -q >/dev/null 2>&1 || ! apt-get install -y dnsutils >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install dnsutils(nslookup)."
    			exit 1
    		fi
    	elif echo "${OS_NAME}" | grep -q -i -e "rocky" -e "fedora"; then
    		if ! dnf update -y --nobest --skip-broken -q >/dev/null 2>&1 || ! dnf install -y bind-utils >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install bind-utils(nslookup)."
    			exit 1
    		fi
    	else
    		echo "[ERROR] Unknown OS type(${OS_NAME})."
    		exit 1
    	fi
    fi
    
    #
    # Check all hostname
    #
    ALL_HOST_NAMES=$(grep 'NAME[[:space:]]*=' "${INI_FILE_PATH}" 2>/dev/null | sed 's/^[[:space:]]*NAME[[:space:]]*=[[:space:]]*//g' 2>/dev/null)
    
    #
    # Sleep time ajusting
    #
    for _ONE_NAME in $(echo "${ALL_HOST_NAMES}" | sort); do
    	if echo "${_ONE_NAME}" | grep -q "$(hostname -f)"; then
    		break
    	fi
    	SLEEP_GAP=$((SLEEP_GAP + 2))
    done
    
    #
    # Wait all host lookup
    #
    DONE_ALL_LOOKUP=0
    while [ "${DONE_ALL_LOOKUP}" -eq 0 ]; do
    	REST_NAMES=""
    	for _ONE_NAME in ${ALL_HOST_NAMES}; do
    		if [ -z "${_ONE_NAME}" ]; then
    			continue
    		fi
    		if ! nslookup "${_ONE_NAME}" >/dev/null 2>&1; then
    			REST_NAMES="${REST_NAMES} ${_ONE_NAME}"
    			continue
    		fi
    		#
    		# Get lastest IP address
    		#
    		_ONE_IP=$(nslookup "${_ONE_NAME}" | grep -i 'address:' | tail -1 | sed -e 's/^[[:space:]]*address:[[:space:]]*//gi')
    
    		if ! nslookup "${_ONE_IP}" >/dev/null 2>&1; then
    			REST_NAMES="${REST_NAMES} ${_ONE_NAME}"
    			continue
    		fi
    		_GET_NAMES=$(nslookup "${_ONE_IP}" | grep -i 'name[[:space:]]*=' | sed -e 's/^.*[[:space:]]*name[[:space:]]*=[[:space:]]*//gi')
    
    		_FIND_NAME_IN_LIST=0
    		for _GET_NAME in ${_GET_NAMES}; do
    			if [ -n "${_GET_NAME}" ]; then
    				if [ "${_GET_NAME}" = "${_ONE_NAME}" ] || [ "${_GET_NAME}" = "${_ONE_NAME}." ]; then
    					_FIND_NAME_IN_LIST=1
    					break;
    				fi
    			fi
    		done
    		if [ "${_FIND_NAME_IN_LIST}" -eq 0 ]; then
    			REST_NAMES="${REST_NAMES} ${_ONE_NAME}"
    		fi
    	done
    
    	ALL_HOST_NAMES=${REST_NAMES}
    
    	if [ -z "${ALL_HOST_NAMES}" ]; then
    		DONE_ALL_LOOKUP=1
    	else
    		if [ "${LOOKUP_RETRYCOUNT}" -le 0 ]; then
    			echo "[ERROR] Lookup hosts is not completed."
    			exit 1
    		fi
    		sleep "${SLEEP_SHORT}"
    		LOOKUP_RETRYCOUNT=$((LOOKUP_RETRYCOUNT - 1))
    	fi
    done
    
    sleep "${SLEEP_GAP}"
    
    #----------------------------------------------------------
    # Main processing
    #----------------------------------------------------------
    #
    # Run chmpx process
    #
    set -e
    
    #
    # stdio/stderr is not redirected.
    #
    chmpx -conf "${INI_FILE_PATH}" -d err
    
    exit $?
    
    #
    # Local variables:
    # tab-width: 4
    # c-basic-offset: 4
    # End:
    # vim600: noexpandtab sw=4 ts=4 fdm=marker
    # vim<600: noexpandtab sw=4 ts=4
    #
    
  k2hr3-k2hdkc-ini-update.sh: |-
    #!/bin/sh
    #
    # K2HR3 Helm Chart
    #
    # Copyright 2022 Yahoo Japan Corporation.
    #
    # K2HR3 is K2hdkc based Resource and Roles and policy Rules, gathers 
    # common management information for the cloud.
    # K2HR3 can dynamically manage information as "who", "what", "operate".
    # These are stored as roles, resources, policies in K2hdkc, and the
    # client system can dynamically read and modify these information.
    #
    # For the full copyright and license information, please view
    # the license file that was distributed with this source code.
    #
    # AUTHOR:   Takeshi Nakatani
    # CREATE:   Wed Jan 19 2022
    # REVISION:
    #
    
    #----------------------------------------------------------
    # Input variables by environment
    #----------------------------------------------------------
    # USING_SERVICE_NAME		Specify this environment variable and specify its name
    #							when using a service such as NodePort
    # CERT_PERIOD_DAYS			Specify period days for certificates
    # CERT_EXTERNAL_HOSTNAME	Specify external hostname or IP address
    #
    # CHMPX_INI_TEMPLATE_FILE	Specify chmpx ini template file path
    #							(ex. /configmap/k2hr3-k2hdkc.ini.templ)
    # CHMPX_INI_DIR				Specify directory path for generated ini file
    #							(ex. /etc/antpickax)
    #
    # CHMPX_MODE				Specify chmpx mode ( SERVER / SLAVE )
    # CHMPX_SERVER_PORT			Specify chmpx port number for server node ( 8020 )
    # CHMPX_SERVER_CTLPORT		Specify chmpx control port number for server node ( 8021 )
    # CHMPX_SLAVE_CTLPORT		Specify chmpx control port number for slave node ( 8022 )
    #
    # CHMPX_SERVER_COUNT		Specify chmpx server nodes count ( 2... )
    # CHMPX_SERVER_NAMEBASE		Specify chmpx server name base ( r3dkc )
    #							Based on this value, the server name, FQDN parts, etc.
    #							are assembled. (ex. svc-r3dkc, pod-r3dkc-0)
    # CHMPX_SLAVE_COUNT			Specify chmpx slave nodes count ( 2... )
    # CHMPX_SLAVE_NAMEBASE		Specify chmpx slave name base ( r3api )
    #							Based on this value, the slave name, FQDN parts, etc.
    #							are assembled. (ex. svc-r3api, pod-r3api-0)
    #
    # CHMPX_POD_NAMESPACE		Specify kubernetes namespace for k2hdkc cluster ( default )
    # CHMPX_DEFAULT_DOMAIN		Specify default local domain name ( svc.cluster.local )
    # CHMPX_SELF_HOSTNAME		Specify self node hostname : Unused ( pod-r3dkc-X / pod-r3api-X )
    #
    # SEC_CA_MOUNTPOINT			Specify mount point for CA certification file
    #
    #----------------------------------------------------------
    # Variables created internally
    #----------------------------------------------------------
    # CHMPX_SELFPORT				Set self control port by this script
    # CHMPX_INI_FILENAME			Set ini file name ( server.ini / slave.ini )
    # CHMPX_SSL_SETTING				Set SSL(TLS) mode and certifications
    #
    set -e
    
    #PRGNAME=$(basename "$0")
    SCRIPTDIR=$(dirname "$0")
    SCRIPTDIR=$(cd "${SCRIPTDIR}" || exit 1; pwd)
    
    #----------------------------------------------------------
    # Common values
    #----------------------------------------------------------
    CHMPX_SELFPORT=0
    CHMPX_INI_FILENAME=""
    DATE=$(date -R)
    
    #----------------------------------------------------------
    # Check enviroment values
    #----------------------------------------------------------
    if [ -z "${CHMPX_INI_TEMPLATE_FILE}" ]; then
    	exit 1
    fi
    if [ -z "${CHMPX_INI_DIR}" ]; then
    	exit 1
    fi
    if [ -z "${CHMPX_SERVER_PORT}" ]; then
    	exit 1
    fi
    if [ -z "${CHMPX_SERVER_CTLPORT}" ]; then
    	exit 1
    fi
    if [ -z "${CHMPX_SLAVE_CTLPORT}" ]; then
    	exit 1
    fi
    if [ -z "${CHMPX_SERVER_COUNT}" ]; then
    	exit 1
    fi
    if [ -z "${CHMPX_SERVER_NAMEBASE}" ]; then
    	exit 1
    fi
    if [ -z "${CHMPX_SLAVE_COUNT}" ]; then
    	exit 1
    fi
    if [ -z "${CHMPX_SLAVE_NAMEBASE}" ]; then
    	exit 1
    fi
    if [ -z "${CHMPX_POD_NAMESPACE}" ]; then
    	exit 1
    fi
    if [ -z "${CHMPX_DEFAULT_DOMAIN}" ]; then
    	exit 1
    fi
    if [ -z "${CHMPX_SELF_HOSTNAME}" ]; then
    	exit 1
    fi
    
    #
    # Allow empty value
    #
    if [ -n "${SEC_CA_MOUNTPOINT}" ] && [ ! -d "${SEC_CA_MOUNTPOINT}" ]; then
    	exit 1
    fi
    
    #----------------------------------------------------------
    # Check ini template file
    #----------------------------------------------------------
    if [ ! -f "${CHMPX_INI_TEMPLATE_FILE}" ]; then
    	exit 1
    fi
    
    #----------------------------------------------------------
    # Check and Create directory
    #----------------------------------------------------------
    mkdir -p "${CHMPX_INI_DIR}"
    
    #----------------------------------------------------------
    # Set chmpx mode and set common values
    #----------------------------------------------------------
    if [ -z "${CHMPX_MODE}" ]; then
    	exit 1
    elif [ "${CHMPX_MODE}" = "SERVER" ] || [ "${CHMPX_MODE}" = "server" ]; then
    	CHMPX_MODE="SERVER"
    	CHMPX_SELFPORT=${CHMPX_SERVER_CTLPORT}
    	CHMPX_INI_FILENAME="server.ini"
    elif [ "${CHMPX_MODE}" = "SLAVE" ] || [ "${CHMPX_MODE}" = "slave" ]; then
    	CHMPX_MODE="SLAVE"
    	CHMPX_SELFPORT=${CHMPX_SLAVE_CTLPORT}
    	CHMPX_INI_FILENAME="slave.ini"
    else
    	exit 1
    fi
    
    #----------------------------------------------------------
    # For certifications
    #----------------------------------------------------------
    GLOBAL_PART_SSL="SSL = no"
    GLOBAL_PART_SSL_VERIFY_PEER=""
    GLOBAL_PART_CAPATH=""
    GLOBAL_PART_SERVER_CERT=""
    GLOBAL_PART_SERVER_PRIKEY=""
    GLOBAL_PART_SLAVE_CERT=""
    GLOBAL_PART_SLAVE_PRIKEY=""
    
    if [ -n "${SEC_CA_MOUNTPOINT}" ]; then
    	#
    	# Create certificate for me
    	#
    	/bin/sh "${SCRIPTDIR}/k2hr3-setup-certificate.sh" "${CHMPX_INI_DIR}" "${SEC_CA_MOUNTPOINT}" "${CERT_PERIOD_DAYS}" "EXTHOSTNAME=${CERT_EXTERNAL_HOSTNAME}" "${USING_SERVICE_NAME}"
    
    	#
    	# Set variables for ini file
    	#
    	GLOBAL_PART_CAPATH="CAPATH = ${CHMPX_INI_DIR}/ca.crt"
    	GLOBAL_PART_SSL="SSL = on"
    	GLOBAL_PART_SSL_VERIFY_PEER="SSL_VERIFY_PEER = on"
    	GLOBAL_PART_SERVER_CERT="SERVER_CERT = ${CHMPX_INI_DIR}/server.crt"
    	GLOBAL_PART_SERVER_PRIKEY="SERVER_PRIKEY = ${CHMPX_INI_DIR}/server.key"
    	GLOBAL_PART_SLAVE_CERT="SLAVE_CERT = ${CHMPX_INI_DIR}/client.crt"
    	GLOBAL_PART_SLAVE_PRIKEY="SLAVE_PRIKEY = ${CHMPX_INI_DIR}/client.key"
    fi
    
    #----------------------------------------------------------
    # Create file
    #----------------------------------------------------------
    {
    	#
    	# Create Base parts
    	#
    	while IFS= read -r ONE_LINE; do
    		if [ -z "${ONE_LINE}" ]; then
    			echo ""
    
    		elif echo "${ONE_LINE}" | grep -q '%%CHMPX_DATE%%'; then
    			echo "${ONE_LINE}" | sed -e "s#%%CHMPX_DATE%%#${DATE}#g"
    
    		elif echo "${ONE_LINE}" | grep -q '%%CHMPX_MODE%%'; then
    			echo "${ONE_LINE}" | sed -e "s#%%CHMPX_MODE%%#${CHMPX_MODE}#g"
    
    		elif echo "${ONE_LINE}" | grep -q '%%CHMPX_SELFPORT%%'; then
    			echo "${ONE_LINE}" | sed -e "s#%%CHMPX_SELFPORT%%#${CHMPX_SELFPORT}#g"
    
    		elif echo "${ONE_LINE}" | grep -q '%%CHMPX_SSL_SETTING%%'; then
    			echo "${GLOBAL_PART_SSL}"
    			echo "${GLOBAL_PART_SSL_VERIFY_PEER}"
    			echo "${GLOBAL_PART_CAPATH}"
    			echo "${GLOBAL_PART_SERVER_CERT}"
    			echo "${GLOBAL_PART_SERVER_PRIKEY}"
    			echo "${GLOBAL_PART_SLAVE_CERT}"
    			echo "${GLOBAL_PART_SLAVE_PRIKEY}"
    
    		else
    			echo "${ONE_LINE}"
    		fi
    	done < "${CHMPX_INI_TEMPLATE_FILE}"
    
    	#
    	# Set server nodes
    	#
    	echo ""
    	echo "#"
    	echo "# SERVER NODES SECTION"
    	echo "#"
    
    	for counter in $(seq "${CHMPX_SERVER_COUNT}"); do
    		NODE_NUMBER=$((counter - 1))
    		NODE_NAME="pod-${CHMPX_SERVER_NAMEBASE}-${NODE_NUMBER}.svc-${CHMPX_SERVER_NAMEBASE}.${CHMPX_POD_NAMESPACE}.${CHMPX_DEFAULT_DOMAIN}"
    
    		echo "[SVRNODE]"
    		echo "NAME           = ${NODE_NAME}"
    		echo "PORT           = ${CHMPX_SERVER_PORT}"
    		echo "CTLPORT        = ${CHMPX_SERVER_CTLPORT}"
    		echo "CUSTOM_ID_SEED = ${NODE_NAME}"
    		echo ""
    	done
    
    	#
    	# Set slave nodes
    	#
    	echo "#"
    	echo "# SLAVE NODES SECTION"
    	echo "#"
    
    	for counter in $(seq "${CHMPX_SLAVE_COUNT}"); do
    		NODE_NUMBER=$((counter - 1))
    		NODE_NAME="pod-${CHMPX_SLAVE_NAMEBASE}-${NODE_NUMBER}.svc-${CHMPX_SLAVE_NAMEBASE}.${CHMPX_POD_NAMESPACE}.${CHMPX_DEFAULT_DOMAIN}"
    
    		echo "[SLVNODE]"
    		echo "NAME           = ${NODE_NAME}"
    		echo "CTLPORT        = ${CHMPX_SLAVE_CTLPORT}"
    		echo "CUSTOM_ID_SEED = ${NODE_NAME}"
    		echo ""
    	done
    
    	#
    	# Footer
    	#
    	echo "#"
    	echo "# Local variables:"
    	echo "# tab-width: 4"
    	echo "# c-basic-offset: 4"
    	echo "# End:"
    	echo "# vim600: noexpandtab sw=4 ts=4 fdm=marker"
    	echo "# vim<600: noexpandtab sw=4 ts=4"
    	echo "#"
    
    } >> "${CHMPX_INI_DIR}/${CHMPX_INI_FILENAME}"
    
    #----------------------------------------------------------
    # Adjustment of startup timing
    #----------------------------------------------------------
    set +e
    
    WAIT_SEC=5
    POD_NUMBER=$(echo "${CHMPX_SELF_HOSTNAME}" | sed 's/-/ /g' | awk '{print $NF}')
    
    if echo "${POD_NUMBER}" | grep -q -v "[^0-9]"; then
    	WAIT_SEC=$((WAIT_SEC * POD_NUMBER))
    fi
    sleep "${WAIT_SEC}"
    
    exit 0
    
    #
    # Local variables:
    # tab-width: 4
    # c-basic-offset: 4
    # End:
    # vim600: noexpandtab sw=4 ts=4 fdm=marker
    # vim<600: noexpandtab sw=4 ts=4
    #
    
  k2hr3-api-wrap.sh: |-
    #!/bin/sh
    #
    # K2HR3 Helm Chart
    #
    # Copyright 2022 Yahoo Japan Corporation.
    #
    # K2HR3 is K2hdkc based Resource and Roles and policy Rules, gathers 
    # common management information for the cloud.
    # K2HR3 can dynamically manage information as "who", "what", "operate".
    # These are stored as roles, resources, policies in K2hdkc, and the
    # client system can dynamically read and modify these information.
    #
    # For the full copyright and license information, please view
    # the license file that was distributed with this source code.
    #
    # AUTHOR:   Takeshi Nakatani
    # CREATE:   Wed Jan 19 2022
    # REVISION:
    #
    
    #----------------------------------------------------------
    # Common variables
    #----------------------------------------------------------
    ANTPICKAX_ETC_DIR="/etc/antpickax"
    
    RETRYCOUNT=30
    FILE_RETRYCOUNT=60
    SLEEP_SHORT=10
    SLEEP_FILE_SHORT=1
    
    #----------------------------------------------------------
    # Configuration file for CHMPX
    #----------------------------------------------------------
    #
    # Always k2hr3_api process is on slave node, if not specified mode.
    #
    K2HR3_CHMPX_MODE="slave"
    INI_FILE="${K2HR3_CHMPX_MODE}.ini"
    INI_FILE_PATH="${ANTPICKAX_ETC_DIR}/${INI_FILE}"
    
    #----------------------------------------------------------
    # Wait configuration file creation
    #----------------------------------------------------------
    FILE_EXISTS=0
    while [ "${FILE_EXISTS}" -eq 0 ]; do
    	if [ -f "${INI_FILE_PATH}" ]; then
    		FILE_EXISTS=1
    	else
    		FILE_RETRYCOUNT=$((FILE_RETRYCOUNT - 1))
    		if [ "${FILE_RETRYCOUNT}" -le 0 ]; then
    			echo "[ERROR] ${INI_FILE_PATH} is not existed."
    			exit 1
    		fi
    		sleep "${SLEEP_FILE_SHORT}"
    	fi
    done
    
    #----------------------------------------------------------
    # Configuration files for K2HR3 API
    #----------------------------------------------------------
    K2HR3_API_DIR=$(find /usr -type d -name 'k2hr3-api' 2>/dev/null | grep node_modules)
    if [ -z "${K2HR3_API_DIR}" ] || [ ! -d "${K2HR3_API_DIR}" ]; then
    	K2HR3_API_DIR=$(find /usr -type d -name 'k2hr3_api' 2>/dev/null | grep node_modules)
    	if [ -z "${K2HR3_API_DIR}" ] || [ ! -d "${K2HR3_API_DIR}" ]; then
    		exit 1
    	fi
    fi
    
    RUN_SCRIPT="${K2HR3_API_DIR}/bin/run.sh"
    PRODUCTION_DIR="${K2HR3_API_DIR}/config"
    
    # [NOTE]
    # Configuration files accept json or json5 extensions.
    #
    PRODUCTION_FILE="${PRODUCTION_DIR}/production.json"
    PRODUCTION5_FILE="${PRODUCTION_DIR}/production.json5"
    CONFIGMAP_PRODUCTION_FILE="/configmap/k2hr3-api-production.json"
    CONFIGMAP_PRODUCTION5_FILE="/configmap/k2hr3-api-production.json5"
    LOCAL_FILE="${PRODUCTION_DIR}/local.json"
    LOCAL5_FILE="${PRODUCTION_DIR}/local.json5"
    CONFIGMAP_LOCAL_FILE="/configmap/k2hr3-api-local.json"
    CONFIGMAP_LOCAL5_FILE="/configmap/k2hr3-api-local.json5"
    
    if [ ! -d "${PRODUCTION_DIR}" ]; then
    	if ! mkdir -p "${PRODUCTION_DIR}"; then
    		exit 1
    	fi
    fi
    if [ -f "${CONFIGMAP_PRODUCTION_FILE}" ]; then
    	if ! cp "${CONFIGMAP_PRODUCTION_FILE}" "${PRODUCTION_FILE}"; then
    		exit 1
    	fi
    elif [ -f "${CONFIGMAP_PRODUCTION5_FILE}" ]; then
    	if ! cp "${CONFIGMAP_PRODUCTION5_FILE}" "${PRODUCTION5_FILE}"; then
    		exit 1
    	fi
    else
    	exit 1
    fi
    if [ -f "${CONFIGMAP_LOCAL_FILE}" ]; then
    	if ! cp "${CONFIGMAP_LOCAL_FILE}" "${LOCAL_FILE}"; then
    		exit 1
    	fi
    elif [ -f "${CONFIGMAP_LOCAL5_FILE}" ]; then
    	if ! cp "${CONFIGMAP_LOCAL5_FILE}" "${LOCAL5_FILE}"; then
    		exit 1
    	fi
    fi
    
    #----------------------------------------------------------
    # Setup OS_NAME
    #----------------------------------------------------------
    if [ ! -f /etc/os-release ]; then
    	echo "[ERROR] Not found /etc/os-release file."
    	exit 1
    fi
    OS_NAME=$(grep '^ID[[:space:]]*=[[:space:]]*' /etc/os-release | sed -e 's|^ID[[:space:]]*=[[:space:]]*||g' -e 's|^[[:space:]]*||g' -e 's|[[:space:]]*$||g' -e 's|"||g')
    
    if echo "${OS_NAME}" | grep -q -i "centos"; then
    	echo "[ERROR] Not support ${OS_NAME}."
    	exit 1
    fi
    
    #----------------------------------------------------------
    # Utility for ubuntu
    #----------------------------------------------------------
    IS_SETUP_APT_ENV=0
    
    setup_apt_envirnment()
    {
    	if [ "${IS_SETUP_APT_ENV}" -eq 1 ]; then
    		return 0
    	fi
    	if [ -n "${HTTP_PROXY}" ] || [ -n "${http_proxy}" ] || [ -n "${HTTPS_PROXY}" ] || [ -n "${https_proxy}" ]; then
    		if [ ! -f /etc/apt/apt.conf.d/00-aptproxy.conf ] || ! grep -q -e 'Acquire::http::Proxy' -e 'Acquire::https::Proxy' /etc/apt/apt.conf.d/00-aptproxy.conf; then
    			_FOUND_HTTP_PROXY=$(if [ -n "${HTTP_PROXY}" ]; then echo "${HTTP_PROXY}"; elif [ -n "${http_proxy}" ]; then echo "${http_proxy}"; else echo ''; fi)
    			_FOUND_HTTPS_PROXY=$(if [ -n "${HTTPS_PROXY}" ]; then echo "${HTTPS_PROXY}"; elif [ -n "${https_proxy}" ]; then echo "${https_proxy}"; else echo ''; fi)
    
    			if [ -n "${_FOUND_HTTP_PROXY}" ] && echo "${_FOUND_HTTP_PROXY}" | grep -q -v '://'; then
    				_FOUND_HTTP_PROXY="http://${_FOUND_HTTP_PROXY}"
    			fi
    			if [ -n "${_FOUND_HTTPS_PROXY}" ] && echo "${_FOUND_HTTPS_PROXY}" | grep -q -v '://'; then
    				_FOUND_HTTPS_PROXY="http://${_FOUND_HTTPS_PROXY}"
    			fi
    			if [ ! -d /etc/apt/apt.conf.d ]; then
    				mkdir -p /etc/apt/apt.conf.d
    			fi
    			{
    				if [ -n "${_FOUND_HTTP_PROXY}" ]; then
    					echo "Acquire::http::Proxy \"${_FOUND_HTTP_PROXY}\";"
    				fi
    				if [ -n "${_FOUND_HTTPS_PROXY}" ]; then
    					echo "Acquire::https::Proxy \"${_FOUND_HTTPS_PROXY}\";"
    				fi
    			} >> /etc/apt/apt.conf.d/00-aptproxy.conf
    		fi
    	fi
    	DEBIAN_FRONTEND=noninteractive
    	export DEBIAN_FRONTEND
    
    	IS_SETUP_APT_ENV=1
    
    	return 0
    }
    
    #----------------------------------------------------------
    # Preparation
    #----------------------------------------------------------
    #
    # Check and Install nslookup
    #
    if ! command -v nslookup >/dev/null 2>&1; then
    	if echo "${OS_NAME}" | grep -q -i "alpine"; then
    		if ! apk update -q --no-progress >/dev/null 2>&1 || ! apk add -q --no-progress --no-cache bind-tools >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install bind-tools(nslookup)."
    			exit 1
    		fi
    	elif echo "${OS_NAME}" | grep -q -i -e "ubuntu" -e "debian"; then
    		setup_apt_envirnment
    		if ! apt-get update -y -q -q >/dev/null 2>&1 || ! apt-get install -y dnsutils >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install dnsutils(nslookup)."
    			exit 1
    		fi
    	elif echo "${OS_NAME}" | grep -q -i -e "rocky" -e "fedora"; then
    		if ! dnf update -y --nobest --skip-broken -q >/dev/null 2>&1 || ! dnf install -y bind-utils >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install bind-utils(nslookup)."
    			exit 1
    		fi
    	else
    		echo "[ERROR] Unknown OS type(${OS_NAME})."
    		exit 1
    	fi
    fi
    
    #
    # Get all hostname
    #
    ALL_HOST_NAMES=$(grep 'NAME[[:space:]]*=' "${INI_FILE_PATH}" 2>/dev/null | sed 's/^[[:space:]]*NAME[[:space:]]*=[[:space:]]*//g' 2>/dev/null)
    
    #
    # Sleep time ajusting
    #
    for _ONE_NAME in $(echo "${ALL_HOST_NAMES}" | sort); do
    	if echo "${_ONE_NAME}" | grep -q "$(hostname -f)"; then
    		break
    	fi
    	SLEEP_GAP=$((SLEEP_GAP + 2))
    done
    
    #
    # Wait all host lookup
    #
    LOOKUP_RETRYCOUNT="${RETRYCOUNT}"
    DONE_ALL_LOOKUP=0
    while [ "${DONE_ALL_LOOKUP}" -eq 0 ]; do
    	REST_NAMES=""
    	for _ONE_NAME in ${ALL_HOST_NAMES}; do
    		if [ -z "${_ONE_NAME}" ]; then
    			continue
    		fi
    		if ! nslookup "${_ONE_NAME}" >/dev/null 2>&1; then
    			REST_NAMES="${REST_NAMES} ${_ONE_NAME}"
    			continue
    		fi
    		#
    		# Get lastest IP address
    		#
    		_ONE_IP=$(nslookup "${_ONE_NAME}" | grep -i 'address:' | tail -1 | sed -e 's/^[[:space:]]*address:[[:space:]]*//gi')
    
    		if ! nslookup "${_ONE_IP}" >/dev/null 2>&1; then
    			REST_NAMES="${REST_NAMES} ${_ONE_NAME}"
    			continue
    		fi
    		_GET_NAMES=$(nslookup "${_ONE_IP}" | grep -i 'name[[:space:]]*=' | sed -e 's/^.*[[:space:]]*name[[:space:]]*=[[:space:]]*//gi')
    
    		_FIND_NAME_IN_LIST=0
    		for _GET_NAME in ${_GET_NAMES}; do
    			if [ -n "${_GET_NAME}" ]; then
    				if [ "${_GET_NAME}" = "${_ONE_NAME}" ] || [ "${_GET_NAME}" = "${_ONE_NAME}." ]; then
    					_FIND_NAME_IN_LIST=1
    					break;
    				fi
    			fi
    		done
    		if [ "${_FIND_NAME_IN_LIST}" -eq 0 ]; then
    			REST_NAMES="${REST_NAMES} ${_ONE_NAME}"
    		fi
    	done
    
    	ALL_HOST_NAMES=${REST_NAMES}
    
    	if [ -z "${ALL_HOST_NAMES}" ]; then
    		DONE_ALL_LOOKUP=1
    	else
    		if [ "${LOOKUP_RETRYCOUNT}" -le 0 ]; then
    			echo "[ERROR] Lookup hosts is not completed."
    			exit 1
    		fi
    		sleep "${SLEEP_SHORT}"
    		LOOKUP_RETRYCOUNT=$((LOOKUP_RETRYCOUNT - 1))
    	fi
    done
    
    #----------------------------------------------------------
    # Main processing
    #----------------------------------------------------------
    #
    # Wait CHMPX up
    #
    CHMPX_UP=0
    while [ "${CHMPX_UP}" -eq 0 ]; do
    	if chmpxstatus -conf "${INI_FILE_PATH}" -self -wait -live up -ring slave -nosuspend -timeout "${SLEEP_SHORT}" >/dev/null 2>&1; then
    		CHMPX_UP=1
    	else
    		sleep "${SLEEP_SHORT}"
    		RETRYCOUNT=$((RETRYCOUNT - 1))
    		if [ "${RETRYCOUNT}" -le 0 ]; then
    			break;
    		fi
    	fi
    done
    if [ "${CHMPX_UP}" -eq 0 ]; then
    	exit 1
    fi
    sleep "${SLEEP_SHORT}"
    
    #
    # Run K2HR3 API
    #
    set -e
    
    if [ -n "${K2HR3_MANUAL_START}" ] && [ "${K2HR3_MANUAL_START}" = "true" ]; then
    	tail -f /dev/null
    else
    	"${RUN_SCRIPT}" --production -fg
    fi
    
    exit $?
    
    #
    # Local variables:
    # tab-width: 4
    # c-basic-offset: 4
    # End:
    # vim600: noexpandtab sw=4 ts=4 fdm=marker
    # vim<600: noexpandtab sw=4 ts=4
    #
    
  k2hr3-app-wrap.sh: |-
    #!/bin/sh
    #
    # K2HR3 Helm Chart
    #
    # Copyright 2022 Yahoo Japan Corporation.
    #
    # K2HR3 is K2hdkc based Resource and Roles and policy Rules, gathers 
    # common management information for the cloud.
    # K2HR3 can dynamically manage information as "who", "what", "operate".
    # These are stored as roles, resources, policies in K2hdkc, and the
    # client system can dynamically read and modify these information.
    #
    # For the full copyright and license information, please view
    # the license file that was distributed with this source code.
    #
    # AUTHOR:   Takeshi Nakatani
    # CREATE:   Wed Jan 19 2022
    # REVISION:
    #
    
    #----------------------------------------------------------
    # Common variables
    #----------------------------------------------------------
    ANTPICKAX_ETC_DIR="/etc/antpickax"
    
    RETRYCOUNT=60
    SLEEP_SHORT=10
    
    #----------------------------------------------------------
    # Configuration files for K2HR3 APP
    #----------------------------------------------------------
    K2HR3_APP_DIR=$(find /usr -type d -name 'k2hr3-app' 2>/dev/null | grep node_modules)
    if [ -z "${K2HR3_APP_DIR}" ] || [ ! -d "${K2HR3_APP_DIR}" ]; then
    	K2HR3_APP_DIR=$(find /usr -type d -name 'k2hr3_app' 2>/dev/null | grep node_modules)
    	if [ -z "${K2HR3_APP_DIR}" ] || [ ! -d "${K2HR3_APP_DIR}" ]; then
    		exit 1
    	fi
    fi
    
    RUN_SCRIPT="${K2HR3_APP_DIR}/bin/run.sh"
    PRODUCTION_DIR="${K2HR3_APP_DIR}/config"
    
    # [NOTE]
    # Configuration files accept json or json5 extensions.
    #
    PRODUCTION_FILE="${PRODUCTION_DIR}/production.json"
    PRODUCTION5_FILE="${PRODUCTION_DIR}/production.json5"
    TARGET_PRODUCTION_FILE=""
    CONFIGMAP_PRODUCTION_FILE="/configmap/k2hr3-app-production.json"
    CONFIGMAP_PRODUCTION5_FILE="/configmap/k2hr3-app-production.json5"
    TARGET_CONFIGMAP_PRODUCTION_FILE=""
    LOCAL_FILE="${PRODUCTION_DIR}/local.json"
    LOCAL5_FILE="${PRODUCTION_DIR}/local.json5"
    CONFIGMAP_LOCAL_FILE="/configmap/k2hr3-app-local.json"
    CONFIGMAP_LOCAL5_FILE="/configmap/k2hr3-app-local.json5"
    
    if [ -f "${CONFIGMAP_PRODUCTION_FILE}" ]; then
    	TARGET_PRODUCTION_FILE="${PRODUCTION_FILE}"
    	TARGET_CONFIGMAP_PRODUCTION_FILE="${CONFIGMAP_PRODUCTION_FILE}"
    elif [ -f "${CONFIGMAP_PRODUCTION5_FILE}" ]; then
    	TARGET_PRODUCTION_FILE="${PRODUCTION5_FILE}"
    	TARGET_CONFIGMAP_PRODUCTION_FILE="${CONFIGMAP_PRODUCTION5_FILE}"
    else
    	exit 1
    fi
    
    #
    # Convert variables:
    #	%%K2HR3_APP_EXTERNAL_HOST%%	-> Environment value(usually not effect, it already set.)
    #	%%K2HR3_APP_EXTERNAL_PORT%%	-> Environment value or NodePort
    #	%%K2HR3_API_EXTERNAL_HOST%%	-> Environment value(usually not effect, it already set.)
    #	%%K2HR3_API_EXTERNAL_PORT%%	-> Environment value or NodePort
    #
    if [ -z "${K2HR3APP_EXTERNAL_PORT}" ] || [ "${K2HR3APP_EXTERNAL_PORT}" = "0" ] ; then
    	if [ -z "${K2HR3APP_SERVICE_NAME}" ]; then
    		exit 1
    	fi
    	TMP_APP_NP_NAME=$(echo "${K2HR3APP_SERVICE_NAME}" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
    	TMP_APP_NP_NAME="${TMP_APP_NP_NAME}_SERVICE_PORT="
    
    	K2HR3APP_EXTERNAL_PORT=$(env | grep "${TMP_APP_NP_NAME}" | sed -e "s/${TMP_APP_NP_NAME}//g")
    fi
    
    if [ -z "${K2HR3API_EXTERNAL_PORT}" ] || [ "${K2HR3API_EXTERNAL_PORT}" = "0" ] ; then
    	if [ -z "${K2HR3API_SERVICE_NAME}" ]; then
    		exit 1
    	fi
    	TMP_API_NP_NAME=$(echo "${K2HR3API_SERVICE_NAME}" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
    	TMP_API_NP_NAME="${TMP_API_NP_NAME}_SERVICE_PORT="
    
    	K2HR3API_EXTERNAL_PORT=$(env | grep "${TMP_API_NP_NAME}" | sed -e "s/${TMP_API_NP_NAME}//g")
    fi
    
    if [ ! -d "${PRODUCTION_DIR}" ]; then
    	if ! mkdir -p "${PRODUCTION_DIR}"; then
    		exit 1
    	fi
    fi
    
    # shellcheck disable=SC2153
    if ! sed -e "s#%%K2HR3_APP_EXTERNAL_HOST%%#${K2HR3APP_EXTERNAL_HOST}#g"	\
    		-e "s#%%K2HR3_APP_EXTERNAL_PORT%%#${K2HR3APP_EXTERNAL_PORT}#g"	\
    		-e "s#%%K2HR3_API_EXTERNAL_HOST%%#${K2HR3API_EXTERNAL_HOST}#g"	\
    		-e "s#%%K2HR3_API_EXTERNAL_PORT%%#${K2HR3API_EXTERNAL_PORT}#g"	\
    		"${TARGET_CONFIGMAP_PRODUCTION_FILE}"							\
    		> "${TARGET_PRODUCTION_FILE}"; then
    	exit 1
    fi
    
    if [ -f "${CONFIGMAP_LOCAL_FILE}" ]; then
    	if ! cp "${CONFIGMAP_LOCAL_FILE}" "${LOCAL_FILE}"; then
    		exit 1
    	fi
    elif [ -f "${CONFIGMAP_LOCAL5_FILE}" ]; then
    	if ! cp "${CONFIGMAP_LOCAL5_FILE}" "${LOCAL5_FILE}"; then
    		exit 1
    	fi
    fi
    
    #----------------------------------------------------------
    # Setup OS_NAME
    #----------------------------------------------------------
    if [ ! -f /etc/os-release ]; then
    	echo "[ERROR] Not found /etc/os-release file."
    	exit 1
    fi
    OS_NAME=$(grep '^ID[[:space:]]*=[[:space:]]*' /etc/os-release | sed -e 's|^ID[[:space:]]*=[[:space:]]*||g' -e 's|^[[:space:]]*||g' -e 's|[[:space:]]*$||g' -e 's|"||g')
    
    if echo "${OS_NAME}" | grep -q -i "centos"; then
    	echo "[ERROR] Not support ${OS_NAME}."
    	exit 1
    fi
    
    #----------------------------------------------------------
    # Utility for ubuntu
    #----------------------------------------------------------
    IS_SETUP_APT_ENV=0
    
    setup_apt_envirnment()
    {
    	if [ "${IS_SETUP_APT_ENV}" -eq 1 ]; then
    		return 0
    	fi
    	if [ -n "${HTTP_PROXY}" ] || [ -n "${http_proxy}" ] || [ -n "${HTTPS_PROXY}" ] || [ -n "${https_proxy}" ]; then
    		if [ ! -f /etc/apt/apt.conf.d/00-aptproxy.conf ] || ! grep -q -e 'Acquire::http::Proxy' -e 'Acquire::https::Proxy' /etc/apt/apt.conf.d/00-aptproxy.conf; then
    			_FOUND_HTTP_PROXY=$(if [ -n "${HTTP_PROXY}" ]; then echo "${HTTP_PROXY}"; elif [ -n "${http_proxy}" ]; then echo "${http_proxy}"; else echo ''; fi)
    			_FOUND_HTTPS_PROXY=$(if [ -n "${HTTPS_PROXY}" ]; then echo "${HTTPS_PROXY}"; elif [ -n "${https_proxy}" ]; then echo "${https_proxy}"; else echo ''; fi)
    
    			if [ -n "${_FOUND_HTTP_PROXY}" ] && echo "${_FOUND_HTTP_PROXY}" | grep -q -v '://'; then
    				_FOUND_HTTP_PROXY="http://${_FOUND_HTTP_PROXY}"
    			fi
    			if [ -n "${_FOUND_HTTPS_PROXY}" ] && echo "${_FOUND_HTTPS_PROXY}" | grep -q -v '://'; then
    				_FOUND_HTTPS_PROXY="http://${_FOUND_HTTPS_PROXY}"
    			fi
    			if [ ! -d /etc/apt/apt.conf.d ]; then
    				mkdir -p /etc/apt/apt.conf.d
    			fi
    			{
    				if [ -n "${_FOUND_HTTP_PROXY}" ]; then
    					echo "Acquire::http::Proxy \"${_FOUND_HTTP_PROXY}\";"
    				fi
    				if [ -n "${_FOUND_HTTPS_PROXY}" ]; then
    					echo "Acquire::https::Proxy \"${_FOUND_HTTPS_PROXY}\";"
    				fi
    			} >> /etc/apt/apt.conf.d/00-aptproxy.conf
    		fi
    	fi
    	DEBIAN_FRONTEND=noninteractive
    	export DEBIAN_FRONTEND
    
    	IS_SETUP_APT_ENV=1
    
    	return 0
    }
    
    #----------------------------------------------------------
    # Certificate files for K2HR3 APP
    #----------------------------------------------------------
    K2HR3_CA_CERT_ORG_FILE="ca.crt"
    K2HR3_CA_CERT_ORG_FILE_PATH="${ANTPICKAX_ETC_DIR}/${K2HR3_CA_CERT_ORG_FILE}"
    
    if [ -f "${K2HR3_CA_CERT_ORG_FILE_PATH}" ]; then
    	if echo "${OS_NAME}" | grep -q -i -e "ubuntu" -e "debian"; then
    		UPDATE_CA_CERT_BIN="update-ca-certificates"
    		UPDATE_CA_CERT_PARAM=""
    		SYSTEM_CA_CERT_DIR="/usr/local/share/ca-certificates"
    
    		if ! command -v "${UPDATE_CA_CERT_BIN}" >/dev/null 2>&1; then
    			setup_apt_envirnment
    			if ! apk-get update -q --no-progress >/dev/null 2>&1 || ! apt-get install -y -q ca-certificates >/dev/null 2>&1; then
    				echo "[WARNING] Failed to install ca-certificates package."
    			fi
    		fi
    	elif echo "${OS_NAME}" | grep -q -i -e "rocky" -e "fedora"; then
    		UPDATE_CA_CERT_BIN="update-ca-trust"
    		UPDATE_CA_CERT_PARAM="extract"
    		SYSTEM_CA_CERT_DIR="/etc/pki/ca-trust/source/anchors"
    
    		if ! command -v "${UPDATE_CA_CERT_BIN}" >/dev/null 2>&1; then
    			if ! dnf update -y --nobest --skip-broken -q >/dev/null 2>&1 || ! dnf install -y -q ca-certificates >/dev/null 2>&1; then
    				echo "[WARNING] Failed to install ca-certificates package."
    			fi
    		fi
    	elif echo "${OS_NAME}" | grep -q -i "alpine"; then
    		UPDATE_CA_CERT_BIN="update-ca-certificates"
    		UPDATE_CA_CERT_PARAM=""
    		SYSTEM_CA_CERT_DIR="/usr/local/share/ca-certificates"
    
    		if ! command -v "${UPDATE_CA_CERT_BIN}" >/dev/null 2>&1; then
    			if ! apk update -q --no-progress >/dev/null 2>&1 || ! apk add -q --no-progress --no-cache ca-certificates >/dev/null 2>&1; then
    				echo "[WARNING] Failed to install ca-certificates package."
    			fi
    		fi
    	else
    		echo "[ERROR] Not support ${OS_NAME}."
    		exit 1
    	fi
    	#
    	# Copy CA cert
    	#
    	if ! cp "${K2HR3_CA_CERT_ORG_FILE_PATH}" "${SYSTEM_CA_CERT_DIR}/${SYSTEM_CA_CERT_K2HR3_FILE}"; then
    		echo "[ERROR] ${PRGNAME} : Failed to copy CA certification."
    		exit 1
    	fi
    	#
    	# Update CA certs
    	#
    	if ! /bin/sh -c "${UPDATE_CA_CERT_BIN} ${UPDATE_CA_CERT_PARAM}"; then
    		echo "[ERROR] ${PRGNAME} : Failed to update CA certifications."
    		exit 1
    	fi
    fi
    
    #----------------------------------------------------------
    # Check curl command and install
    #----------------------------------------------------------
    if ! CURL_COMMAND=$(command -v curl 2>/dev/null); then
    	if echo "${OS_NAME}" | grep -q -i -e "ubuntu" -e "debian"; then
    		setup_apt_envirnment
    		if ! apt-get update -y -q -q >/dev/null 2>&1 || ! apt-get install -y -q curl >/dev/null 2>&1; then
    			echo "[ERROR] ${PRGNAME} : Failed to install curl for ${OS_NAME}."
    			exit 1
    		fi
    	elif echo "${OS_NAME}" | grep -q -i -e "rocky" -e "fedora"; then
    		if ! dnf update -y --nobest --skip-broken -q >/dev/null 2>&1 || ! dnf install -y -q curl >/dev/null 2>&1; then
    			echo "[ERROR] ${PRGNAME} : Failed to install curl for ${OS_NAME}."
    			exit 1
    		fi
    	elif echo "${OS_NAME}" | grep -q -i "alpine"; then
    		if ! apk update -q --no-progress >/dev/null 2>&1 || ! apk add -q --no-progress --no-cache curl >/dev/null 2>&1; then
    			echo "[ERROR] ${PRGNAME} : Failed to install curl for ${OS_NAME}."
    			exit 1
    		fi
    	else
    		echo "[ERROR] Not support ${OS_NAME}."
    		exit 1
    	fi
    
    	if ! CURL_COMMAND=$(command -v curl 2>/dev/null); then
    		echo "[ERROR] ${PRGNAME} : Could not install curl for ${OS_NAME}."
    		exit 1
    	fi
    fi
    
    #----------------------------------------------------------
    # Main processing
    #----------------------------------------------------------
    #
    # Wait for api server up
    #
    if [ -z "${K2HR3APP_RUN_ON_MINIKUBE}" ] || [ "${K2HR3APP_RUN_ON_MINIKUBE}" != "true" ]; then
    	API_SCHEMA=$(grep 'apischeme' "${TARGET_PRODUCTION_FILE}" 2>/dev/null | sed -e "s/['|,]//g" -e 's/^[[:space:]]*apischeme:[[:space:]]*//g' 2>/dev/null)
    	API_UP=0
    	while [ "${API_UP}" -eq 0 ]; do
    		if HTTP_CODE=$("${CURL_COMMAND}" -s -S -w '%{http_code}' -o /dev/null --insecure -X GET "${API_SCHEMA}://${K2HR3API_EXTERNAL_HOST}:${K2HR3API_EXTERNAL_PORT}/" 2>&1); then
    			if [ -n "${HTTP_CODE}" ] && [ "${HTTP_CODE}" -eq 200 ]; then
    				API_UP=1
    			fi
    		fi
    		if [ "${API_UP}" -ne 1 ]; then
    			sleep "${SLEEP_SHORT}"
    			RETRYCOUNT=$((RETRYCOUNT - 1))
    			if [ "${RETRYCOUNT}" -le 0 ]; then
    				break;
    			fi
    		fi
    	done
    	if [ "${API_UP}" -eq 0 ]; then
    		exit 1
    	fi
    fi
    sleep "${SLEEP_SHORT}"
    
    #
    # Run K2HR3 APP
    #
    set -e
    
    if [ -n "${K2HR3_MANUAL_START}" ] && [ "${K2HR3_MANUAL_START}" = "true" ]; then
    	tail -f /dev/null
    else
    	"${RUN_SCRIPT}" --production -fg
    fi
    
    exit $?
    
    #
    # Local variables:
    # tab-width: 4
    # c-basic-offset: 4
    # End:
    # vim600: noexpandtab sw=4 ts=4 fdm=marker
    # vim<600: noexpandtab sw=4 ts=4
    #
    
  k2hr3-app-init.sh: |-
    #!/bin/sh
    #
    # K2HR3 Helm Chart
    #
    # Copyright 2022 Yahoo Japan Corporation.
    #
    # K2HR3 is K2hdkc based Resource and Roles and policy Rules, gathers 
    # common management information for the cloud.
    # K2HR3 can dynamically manage information as "who", "what", "operate".
    # These are stored as roles, resources, policies in K2hdkc, and the
    # client system can dynamically read and modify these information.
    #
    # For the full copyright and license information, please view
    # the license file that was distributed with this source code.
    #
    # AUTHOR:   Takeshi Nakatani
    # CREATE:   Wed Jan 19 2022
    # REVISION:
    #
    
    #----------------------------------------------------------
    # Input variables by environment
    #----------------------------------------------------------
    # USING_SERVICE_NAME		Specify this environment variable and specify its name
    #							when using a service such as NodePort
    # ANTPICKAX_ETC_DIR			Specify directory path for files ( /etc/antpickax )
    # CERT_PERIOD_DAYS			Specify period days for certificates
    # CERT_EXTERNAL_HOSTNAME	Specify external hostname or IP address
    # SEC_CA_MOUNTPOINT			Specify mount point for CA certificate file
    #
    set -e
    
    #PRGNAME=$(basename "$0")
    SCRIPTDIR=$(dirname "$0")
    SCRIPTDIR=$(cd "${SCRIPTDIR}" || exit 1; pwd)
    
    #----------------------------------------------------------
    # Check enviroment values
    #----------------------------------------------------------
    if [ -z "${ANTPICKAX_ETC_DIR}" ]; then
    	exit 1
    fi
    
    #
    # Allow empty value
    #
    if [ -n "${SEC_CA_MOUNTPOINT}" ] && [ ! -d "${SEC_CA_MOUNTPOINT}" ]; then
    	exit 1
    fi
    
    #----------------------------------------------------------
    # Certificates
    #----------------------------------------------------------
    if [ -n "${SEC_CA_MOUNTPOINT}" ]; then
    	#
    	# Create certificate for me
    	#
    	/bin/sh "${SCRIPTDIR}/k2hr3-setup-certificate.sh" "${ANTPICKAX_ETC_DIR}" "${SEC_CA_MOUNTPOINT}" "${CERT_PERIOD_DAYS}" "EXTHOSTNAME=${CERT_EXTERNAL_HOSTNAME}" "${USING_SERVICE_NAME}"
    fi
    
    exit 0
    
    #
    # Local variables:
    # tab-width: 4
    # c-basic-offset: 4
    # End:
    # vim600: noexpandtab sw=4 ts=4 fdm=marker
    # vim<600: noexpandtab sw=4 ts=4
    #
    
  k2hr3-setup-certificate.sh: |-
    #!/bin/sh
    #
    # K2HR3 Helm Chart
    #
    # Copyright 2022 Yahoo Japan Corporation.
    #
    # K2HR3 is K2hdkc based Resource and Roles and policy Rules, gathers 
    # common management information for the cloud.
    # K2HR3 can dynamically manage information as "who", "what", "operate".
    # These are stored as roles, resources, policies in K2hdkc, and the
    # client system can dynamically read and modify these information.
    #
    # For the full copyright and license information, please view
    # the license file that was distributed with this source code.
    #
    # AUTHOR:   Takeshi Nakatani
    # CREATE:   Wed Jan 19 2022
    # REVISION:
    #
    
    #----------------------------------------------------------
    # Usage: script <output dir> <CA certs dir> <period days> <service name> <service name>...
    # 
    # Specify the name of the service that has the ClusterIP,
    # such as NodePort.
    # Get the IP address from the environment variable using
    # the specified service name.
    # The obtained IP address will be used as the IP address
    # of the SAN of the certificate.
    #
    #----------------------------------------------------------
    PRGNAME=$(basename "$0")
    SCRIPTDIR=$(dirname "$0")
    SCRIPTDIR=$(cd "${SCRIPTDIR}" || exit 1; pwd)
    
    #----------------------------------------------------------
    # Parse parameter
    #----------------------------------------------------------
    #
    # 1'st parameter is output directory path(ex. /etc/antpickax).
    #
    if [ $# -lt 1 ]; then
    	echo "[ERROR] First paranmeter for output directory path is needed."
    	exit 1
    fi
    if [ ! -d "$1" ]; then
    	echo "[ERROR] First paranmeter for output directory path is not directory."
    	exit 1
    fi
    OUTPUT_DIR="$1"
    shift
    
    #
    # 2'nd parameter is directory path(ex. /secret-ca) for CA certificate.
    #
    if [ $# -lt 1 ]; then
    	echo "[ERROR] Second paranmeter for CA certificate directory path is needed."
    	exit 1
    fi
    if [ ! -d "$1" ]; then
    	echo "[ERROR] Second paranmeter for CA certificate directory path is not directory."
    	exit 1
    fi
    CA_CERT_DIR="$1"
    shift
    
    #
    # 3'rd parameter is period days for certificate(ex. 3650).
    #
    if [ $# -lt 1 ]; then
    	echo "[ERROR] Third paranmeter for period days is not specified."
    	exit 1
    fi
    if echo "$1" | grep -q '[^0-9]'; then
    	echo "[ERROR] Third paranmeter for period days is not number."
    	exit 1
    fi
    CERT_PERIOD_DAYS="$1"
    shift
    
    #
    # 4'th parameter is external hostname.
    #
    if [ $# -lt 1 ]; then
    	echo "[ERROR] 4th paranmeter is not existed."
    	exit 1
    fi
    SAN_EXTHOSTNAME=""
    TMP_EXTHOSTNAME=$(echo "$1" | sed -e 's/EXTHOSTNAME=//g')
    if [ -n "${TMP_EXTHOSTNAME}" ]; then
    	if echo "${TMP_EXTHOSTNAME}" | grep -q -E -o '^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$' 2>/dev/null; then
    		SAN_EXTHOSTNAME="IP:${TMP_EXTHOSTNAME}"
    	else
    		if echo "${TMP_EXTHOSTNAME}" | grep -q -E -o '^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$'; then
    			SAN_EXTHOSTNAME="IP:${TMP_EXTHOSTNAME}"
    		else
    			SAN_EXTHOSTNAME="DNS:${TMP_EXTHOSTNAME}"
    		fi
    	fi
    fi
    
    #
    # After parameters are Service name for IP address
    #
    SERVICE_IP_SANS=""
    while [ $# -ne 0 ]; do
    	if [ -n "$1" ]; then
    		#
    		# Parameter is service name(ex. "np-r3app").
    		# Then convert it to environment name(ex. NP_R3APP_SERVICE_HOST) for IP address
    		#
    		TMP_SERVICE_NAME=$(echo "$1" | tr '[:lower:]' '[:upper:]' | tr '-' '_')
    		TMP_SERVICE_NAME="${TMP_SERVICE_NAME}_SERVICE_HOST="
    		TMP_SERVICE_IP=$(env | grep "${TMP_SERVICE_NAME}" | sed -e "s/${TMP_SERVICE_NAME}//g")
    
    		if [ -n "${TMP_SERVICE_IP}" ]; then
    			if [ -z "${SERVICE_IP_SANS}" ]; then
    				SERVICE_IP_SANS="IP:${TMP_SERVICE_IP}"
    			else
    				SERVICE_IP_SANS="${SERVICE_IP_SANS}, IP:${TMP_SERVICE_IP}"
    			fi
    		fi
    	fi
    	shift
    done
    
    #----------------------------------------------------------
    # Variables
    #----------------------------------------------------------
    #
    # Hostnames / IP addresses
    #
    # LOCAL_DOMAIN			ex. default.svc.cluster.local
    # LOCAL_HOST_DOMAIN		ex. svc.default.svc.cluster.local
    # FULL_HOST_NAME		ex. pod.svc.default.svc.cluster.local
    # SHORT_HOST_NAME		ex. pod
    # NODOMAIN_HOST_NAME	ex. pod.svc
    #
    LOCAL_DOMAIN="${CHMPX_POD_NAMESPACE}.${CHMPX_DEFAULT_DOMAIN}"
    LOCAL_HOST_DOMAIN=$(hostname -d)
    LOCAL_HOST_IP=$(hostname -i)
    FULL_HOST_NAME=$(hostname -f)
    SHORT_HOST_NAME=$(hostname -s)
    NODOMAIN_HOST_NAME=$(echo "${FULL_HOST_NAME}" | sed -e "s/\.${LOCAL_DOMAIN}//g")
    
    #
    # Certificate directories / files
    #
    CERT_WORK_DIR="${OUTPUT_DIR}/certwork"
    
    if [ ! -d "${CERT_WORK_DIR}" ]; then
    	if ! mkdir -p "${CERT_WORK_DIR}"; then
    		echo "[ERROR] Could not create directory ${CERT_WORK_DIR}"
    		exit 1
    	fi
    	if ! mkdir -p "${CERT_WORK_DIR}/private"; then
    		echo "[ERROR] Could not create directory ${CERT_WORK_DIR}/private"
    		exit 1
    	fi
    	if ! mkdir -p "${CERT_WORK_DIR}/newcerts"; then
    		echo "[ERROR] Could not create directory ${CERT_WORK_DIR}/newcerts"
    		exit 1
    	fi
    	if ! mkdir -p "${CERT_WORK_DIR}/oldcerts"; then
    		echo "[ERROR] Could not create directory ${CERT_WORK_DIR}/oldcerts"
    		exit 1
    	fi
    	if ! date +%s > "${CERT_WORK_DIR}/serial"; then
    		echo "[ERROR] Could not create file ${CERT_WORK_DIR}/serial"
    		exit 1
    	fi
    	if ! touch "${CERT_WORK_DIR}/index.txt"; then
    		echo "[ERROR] Could not create file ${CERT_WORK_DIR}/index.txt"
    		exit 1
    	fi
    fi
    
    #
    # Configration files for openssl
    #
    ORG_OPENSSL_CNF="/etc/ssl/openssl.cnf"
    CUSTOM_OPENSSL_CNF="${CERT_WORK_DIR}/openssl.cnf"
    
    SUBJ_CSR_C="JP"
    SUBJ_CSR_S="Tokyo"
    SUBJ_CSR_O="AntPickax"
    
    #
    # CA certificate / private key files
    #
    # ORG_CA_CERT_FILE	CA certification(ex. default.svc.cluster.local_CA.crt)
    # ORG_CA_KEY_FILE	CA private key(ex. default.svc.cluster.local_CA.key)
    #
    ORG_CA_CERT_FILE=$(find "${CA_CERT_DIR}/" -name '*_CA.crt' | head -1)
    ORG_CA_KEY_FILE=$(find "${CA_CERT_DIR}/" -name '*_CA.key' | head -1)
    if [ -z "${ORG_CA_CERT_FILE}" ] || [ -z "${ORG_CA_KEY_FILE}" ]; then
    	echo "[ERROR] CA certificate file or private key file are not existed."
    	exit 1
    fi
    cp -p "${ORG_CA_CERT_FILE}" "${CERT_WORK_DIR}/cacert.pem"
    cp -p "${ORG_CA_KEY_FILE}"  "${CERT_WORK_DIR}/private/cakey.pem"
    chmod 0400 "${CERT_WORK_DIR}/private/cakey.pem"
    
    #
    # Certificate and private files
    #
    RAW_CERT_FILE="${CERT_WORK_DIR}/${FULL_HOST_NAME}.crt"
    RAW_CSR_FILE="${CERT_WORK_DIR}/${FULL_HOST_NAME}.csr"
    RAW_KEY_FILE="${CERT_WORK_DIR}/${FULL_HOST_NAME}.key"
    
    CA_CERT_FILE="${OUTPUT_DIR}/ca.crt"
    SERVER_CERT_FILE="${OUTPUT_DIR}/server.crt"
    SERVER_KEY_FILE="${OUTPUT_DIR}/server.key"
    CLIENT_CERT_FILE="${OUTPUT_DIR}/client.crt"
    CLIENT_KEY_FILE="${OUTPUT_DIR}/client.key"
    
    #
    # Others
    #
    LOG_FILE="${CERT_WORK_DIR}/${PRGNAME}.log"
    
    #----------------------------------------------------------
    # Setup OS_NAME
    #----------------------------------------------------------
    if [ ! -f /etc/os-release ]; then
    	echo "[ERROR] Not found /etc/os-release file."
    	exit 1
    fi
    OS_NAME=$(grep '^ID[[:space:]]*=[[:space:]]*' /etc/os-release | sed -e 's|^ID[[:space:]]*=[[:space:]]*||g' -e 's|^[[:space:]]*||g' -e 's|[[:space:]]*$||g' -e 's|"||g')
    
    if echo "${OS_NAME}" | grep -q -i "centos"; then
    	echo "[ERROR] Not support ${OS_NAME}."
    	exit 1
    fi
    
    #----------------------------------------------------------
    # Utility for ubuntu
    #----------------------------------------------------------
    IS_SETUP_APT_ENV=0
    
    setup_apt_envirnment()
    {
    	if [ "${IS_SETUP_APT_ENV}" -eq 1 ]; then
    		return 0
    	fi
    	if [ -n "${HTTP_PROXY}" ] || [ -n "${http_proxy}" ] || [ -n "${HTTPS_PROXY}" ] || [ -n "${https_proxy}" ]; then
    		if [ ! -f /etc/apt/apt.conf.d/00-aptproxy.conf ] || ! grep -q -e 'Acquire::http::Proxy' -e 'Acquire::https::Proxy' /etc/apt/apt.conf.d/00-aptproxy.conf; then
    			_FOUND_HTTP_PROXY=$(if [ -n "${HTTP_PROXY}" ]; then echo "${HTTP_PROXY}"; elif [ -n "${http_proxy}" ]; then echo "${http_proxy}"; else echo ''; fi)
    			_FOUND_HTTPS_PROXY=$(if [ -n "${HTTPS_PROXY}" ]; then echo "${HTTPS_PROXY}"; elif [ -n "${https_proxy}" ]; then echo "${https_proxy}"; else echo ''; fi)
    
    			if [ -n "${_FOUND_HTTP_PROXY}" ] && echo "${_FOUND_HTTP_PROXY}" | grep -q -v '://'; then
    				_FOUND_HTTP_PROXY="http://${_FOUND_HTTP_PROXY}"
    			fi
    			if [ -n "${_FOUND_HTTPS_PROXY}" ] && echo "${_FOUND_HTTPS_PROXY}" | grep -q -v '://'; then
    				_FOUND_HTTPS_PROXY="http://${_FOUND_HTTPS_PROXY}"
    			fi
    			if [ ! -d /etc/apt/apt.conf.d ]; then
    				mkdir -p /etc/apt/apt.conf.d
    			fi
    			{
    				if [ -n "${_FOUND_HTTP_PROXY}" ]; then
    					echo "Acquire::http::Proxy \"${_FOUND_HTTP_PROXY}\";"
    				fi
    				if [ -n "${_FOUND_HTTPS_PROXY}" ]; then
    					echo "Acquire::https::Proxy \"${_FOUND_HTTPS_PROXY}\";"
    				fi
    			} >> /etc/apt/apt.conf.d/00-aptproxy.conf
    		fi
    	fi
    	DEBIAN_FRONTEND=noninteractive
    	export DEBIAN_FRONTEND
    
    	IS_SETUP_APT_ENV=1
    
    	return 0
    }
    
    #----------------------------------------------------------
    # Check openssl command
    #----------------------------------------------------------
    if ! OPENSSL_COMMAND=$(command -v openssl 2>/dev/null); then
    	if echo "${OS_NAME}" | grep -q -i "alpine"; then
    		if ! apk update -q --no-progress >/dev/null 2>&1 || ! apk add -q --no-progress --no-cache openssl >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install openssl."
    			exit 1
    		fi
    	elif echo "${OS_NAME}" | grep -q -i -e "ubuntu" -e "debian"; then
    		setup_apt_envirnment
    		if ! apt-get update -y -q -q >/dev/null 2>&1 || ! apt-get install -y openssl >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install openssl."
    			exit 1
    		fi
    	elif echo "${OS_NAME}" | grep -q -i -e "rocky" -e "fedora"; then
    		if ! dnf update -y --nobest --skip-broken -q >/dev/null 2>&1 || ! dnf install -y openssl >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install openssl."
    			exit 1
    		fi
    	else
    		echo "[ERROR] Unknown OS type(${OS_NAME})."
    		exit 1
    	fi
    
    	if ! OPENSSL_COMMAND=$(command -v openssl 2>/dev/null); then
    		echo "[ERROR] Could not install openssl for ${OS_NAME}."
    		exit 1
    	fi
    fi
    
    #----------------------------------------------------------
    # Create openssl.cnf 
    #----------------------------------------------------------
    if [ ! -f "${ORG_OPENSSL_CNF}" ]; then
    	echo "[ERROR] Could not find file ${ORG_OPENSSL_CNF}"
    	exit 1
    fi
    
    #
    # Create openssl.cnf from /etc/pki/tls/openssl.cnf
    # Modify values
    #	unique_subject		= no						in [ CA_default ] section
    #	email_in_dn			= no						in [ CA_default ] section
    #	rand_serial			= no						in [ CA_default ] section
    #	unique_subject		= no						in [ CA_default ] section
    #	dir      			= <K2HDKC DBaaS K8S domain>	in [ CA_default ] section
    #	keyUsage 			= cRLSign, keyCertSign		in [ v3_ca ] section
    #	countryName			= optional					in [ policy_match ] section
    #	stateOrProvinceName = optional					in [ policy_match ] section
    #	organizationName	= optional					in [ policy_match ] section
    #
    while IFS= read -r ONE_LINE; do
    	if [ -z "${ONE_LINE}" ]; then
    		echo ""
    
    	elif echo "${ONE_LINE}" | grep -q '[[[:space:]]*CA_default[[:space:]]*]'; then
    		echo '[ CA_default ]'
    		echo 'unique_subject = no'
    		echo 'email_in_dn = no'
    		echo 'rand_serial = no'
    
    	elif echo "${ONE_LINE}" | grep -q '[[[:space:]]*v3_ca[[:space:]]*]'; then
    		echo '[ v3_ca ]'
    		echo 'keyUsage = cRLSign, keyCertSign'
    
    	elif echo "${ONE_LINE}" | grep -q '^dir[[:space:]]*=[[:space:]]*.*CA.*'; then
    		echo "dir = ${CERT_WORK_DIR}"
    
    	elif echo "${ONE_LINE}" | grep -q '^[[:space:]]*countryName[[:space:]]*=[[:space:]]*match.*$'; then
    		echo 'countryName = optional'
    
    	elif echo "${ONE_LINE}" | grep -q '^[[:space:]]*stateOrProvinceName[[:space:]]*=[[:space:]]*match.*$'; then
    		echo 'stateOrProvinceName = optional'
    
    	elif echo "${ONE_LINE}" | grep -q '^[[:space:]]*organizationName[[:space:]]*=[[:space:]]*match.*$'; then
    		echo 'organizationName = optional'
    
    	else
    		echo "${ONE_LINE}"
    	fi
    done < "${ORG_OPENSSL_CNF}" > "${CUSTOM_OPENSSL_CNF}"
    
    #
    # Add section to  openssl.cnf
    #	[ v3_svr_clt ]									add section
    #
    SAN_SETTINGS=""
    if [ -n "${FULL_HOST_NAME}" ]; then
    	SAN_SETTINGS="DNS:${FULL_HOST_NAME}"
    fi
    if [ -n "${LOCAL_HOST_DOMAIN}" ]; then
    	if [ -z "${SAN_SETTINGS}" ]; then
    		SAN_SETTINGS="DNS:${LOCAL_HOST_DOMAIN}"
    	else
    		SAN_SETTINGS="${SAN_SETTINGS}, DNS:${LOCAL_HOST_DOMAIN}"
    	fi
    fi
    if [ -n "${SHORT_HOST_NAME}" ]; then
    	if [ -z "${SAN_SETTINGS}" ]; then
    		SAN_SETTINGS="DNS:${SHORT_HOST_NAME}"
    	else
    		SAN_SETTINGS="${SAN_SETTINGS}, DNS:${SHORT_HOST_NAME}"
    	fi
    fi
    if [ -n "${NODOMAIN_HOST_NAME}" ]; then
    	if [ -z "${SAN_SETTINGS}" ]; then
    		SAN_SETTINGS="DNS:${NODOMAIN_HOST_NAME}"
    	else
    		SAN_SETTINGS="${SAN_SETTINGS}, DNS:${NODOMAIN_HOST_NAME}"
    	fi
    fi
    if [ -n "${LOCAL_HOST_IP}" ]; then
    	if [ -z "${SAN_SETTINGS}" ]; then
    		SAN_SETTINGS="IP:${LOCAL_HOST_IP}"
    	else
    		SAN_SETTINGS="${SAN_SETTINGS}, IP:${LOCAL_HOST_IP}"
    	fi
    fi
    if [ -n "${SERVICE_IP_SANS}" ]; then
    	if [ -z "${SAN_SETTINGS}" ]; then
    		SAN_SETTINGS="${SERVICE_IP_SANS}"
    	else
    		SAN_SETTINGS="${SAN_SETTINGS}, ${SERVICE_IP_SANS}"
    	fi
    fi
    if [ -n "${SAN_EXTHOSTNAME}" ]; then
    	if [ -z "${SAN_SETTINGS}" ]; then
    		SAN_SETTINGS="${SAN_EXTHOSTNAME}"
    	else
    		SAN_SETTINGS="${SAN_SETTINGS}, ${SAN_EXTHOSTNAME}"
    	fi
    fi
    {
    	echo ""
    	echo "[ v3_svr_clt ]"
    	echo "basicConstraints=CA:FALSE"
    	echo "keyUsage = digitalSignature, keyEncipherment"
    	echo "extendedKeyUsage = serverAuth, clientAuth"
    	echo "subjectKeyIdentifier=hash"
    	echo "authorityKeyIdentifier=keyid,issuer"
    	if [ -n "${SAN_SETTINGS}" ]; then
    		echo "subjectAltName = ${SAN_SETTINGS}"
    	fi
    } >> "${CUSTOM_OPENSSL_CNF}"
    
    # shellcheck disable=SC2181
    if [ $? -ne 0 ]; then
    	echo "[ERROR] Could not modify file ${CUSTOM_OPENSSL_CNF}"
    	exit 1
    fi
    
    #----------------------------------------------------------
    # Create certificates
    #----------------------------------------------------------
    #
    # Create private key(2048 bit) without passphrase
    #
    if ! "${OPENSSL_COMMAND}" genrsa	\
    		-out "${RAW_KEY_FILE}"		\
    		2048						\
    		>> "${LOG_FILE}" 2>&1; then
    
    	echo "[ERROR] Failed to create ${RAW_KEY_FILE} private key."
    	exit 1
    fi
    
    if ! chmod 0400 "${RAW_KEY_FILE}"; then
    	echo "[ERROR] Failed to set permission(0400) to ${RAW_KEY_FILE} private key."
    	exit 1
    fi
    
    #
    # Create CSR file
    #
    if ! "${OPENSSL_COMMAND}" req	\
    		-new					\
    		-key  "${RAW_KEY_FILE}"	\
    		-out  "${RAW_CSR_FILE}"	\
    		-subj "/C=${SUBJ_CSR_C}/ST=${SUBJ_CSR_S}/O=${SUBJ_CSR_O}/CN=${NODOMAIN_HOST_NAME}"	\
    		>> "${LOG_FILE}" 2>&1; then
    
    	echo "[ERROR] Failed to create ${RAW_CSR_FILE} CSR file."
    	exit 1
    fi
    
    #
    # Create certificate file
    #
    if ! "${OPENSSL_COMMAND}" ca				\
    		-batch								\
    		-extensions	v3_svr_clt				\
    		-out		"${RAW_CERT_FILE}"		\
    		-days		"${CERT_PERIOD_DAYS}"	\
    		-passin		"pass:"					\
    		-config		"${CUSTOM_OPENSSL_CNF}" \
    		-infiles	"${RAW_CSR_FILE}"		\
    		>> "${LOG_FILE}" 2>&1; then
    
    	echo "[ERROR] Failed to create ${RAW_CERT_FILE} certificate file."
    	exit 1
    fi
    
    #----------------------------------------------------------
    # Set files to /etc/antpickax
    #----------------------------------------------------------
    if	! cp -p "${ORG_CA_CERT_FILE}"	"${CA_CERT_FILE}"		||
    	! cp -p "${RAW_CERT_FILE}"		"${SERVER_CERT_FILE}"	||
    	! cp -p "${RAW_KEY_FILE}"		"${SERVER_KEY_FILE}"	||
    	! cp -p "${RAW_CERT_FILE}"		"${CLIENT_CERT_FILE}"	||
    	! cp -p "${RAW_KEY_FILE}"		"${CLIENT_KEY_FILE}"	||
    	! chmod 0444 "${CA_CERT_FILE}"							||
    	! chmod 0444 "${SERVER_CERT_FILE}"						||
    	! chmod 0400 "${SERVER_KEY_FILE}"						||
    	! chmod 0444 "${CLIENT_CERT_FILE}"						||
    	! chmod 0400 "${CLIENT_KEY_FILE}"; then
    
    	echo "[ERROR] Failed to copy certificate files."
    	exit 1
    fi
    
    #
    # Cleanup files
    #
    if ! rm -rf "${CERT_WORK_DIR}"; then
    	echo "[ERROR] Could not remove directory ${CERT_WORK_DIR}"
    	exit 1
    fi
    
    exit 0
    
    #
    # Local variables:
    # tab-width: 4
    # c-basic-offset: 4
    # End:
    # vim600: noexpandtab sw=4 ts=4 fdm=marker
    # vim<600: noexpandtab sw=4 ts=4
    #
    
  k2hr3-check.sh: |-
    #!/bin/sh
    #
    # K2HR3 Helm Chart
    #
    # Copyright 2022 Yahoo Japan Corporation.
    #
    # K2HR3 is K2hdkc based Resource and Roles and policy Rules, gathers 
    # common management information for the cloud.
    # K2HR3 can dynamically manage information as "who", "what", "operate".
    # These are stored as roles, resources, policies in K2hdkc, and the
    # client system can dynamically read and modify these information.
    #
    # For the full copyright and license information, please view
    # the license file that was distributed with this source code.
    #
    # AUTHOR:   Takeshi Nakatani
    # CREATE:   Wed Jan 19 2022
    # REVISION:
    #
    
    #----------------------------------------------------------
    # Input variables by environment
    #----------------------------------------------------------
    # K2HR3_NAMESPACE				k2hr3 namespace(ex. "default")
    # K2HR3_BASE_DOMAIN				k2hr3 base domain name(ex. "svc.cluster.local")
    #
    # K2HR3API_COUNT				k2hr3api server(pod) count(ex. 2)
    # K2HR3API_LOCAL_BASE_HOSTNAME	k2hr3api base name for hostname(ex. "pod-r3api-dbaask2hr3-")
    # K2HR3API_LOCAL_SVC_NAME		k2hr3api service name(ex. "svc-r3api-dbaask2hr3")
    # K2HR3API_LOCAL_PORT			k2hr3api local port number(ex. 443)
    # K2HR3API_NP_BASE_HOSTNAME		k2hr3api NodePort hostname(ex. "np-r3api-dbaask2hr3")
    # K2HR3API_NP_PORT				k2hr3api NodePort port number(ex. 8443)
    # 
    # K2HR3APP_NP_BASE_HOSTNAME		k2hr3app NodePort hostname(ex. "np-r3app-dbaask2hr3")
    # K2HR3APP_NP_PORT				k2hr3api NodePort port number(ex. 8443)
    #
    PRGNAME=$(basename "$0")
    SCRIPTDIR=$(dirname "$0")
    SCRIPTDIR=$(cd "${SCRIPTDIR}" || exit 1; pwd)
    
    #----------------------------------------------------------
    # Common values
    #----------------------------------------------------------
    TIMESTAMP=$(date "+%Y-%m-%d-%H:%M:%S")
    RESULT_CONTENTS_FILE="/tmp/result-${TIMESTAMP}.log"
    
    #----------------------------------------------------------
    # Check enviroment values
    #----------------------------------------------------------
    if [ -z "${K2HR3_NAMESPACE}" ]; then
    	echo "[ERROR] ${PRGNAME} : K2HR3_NAMESPACE environment is not specified."
    	exit 1
    fi
    if [ -z "${K2HR3_BASE_DOMAIN}" ]; then
    	echo "[ERROR] ${PRGNAME} : K2HR3_BASE_DOMAIN environment is not specified."
    	exit 1
    fi
    if [ -z "${K2HR3API_COUNT}" ]; then
    	echo "[ERROR] ${PRGNAME} : K2HR3API_COUNT environment is not specified."
    	exit 1
    fi
    if [ -z "${K2HR3API_LOCAL_BASE_HOSTNAME}" ]; then
    	echo "[ERROR] ${PRGNAME} : K2HR3API_LOCAL_BASE_HOSTNAME environment is not specified."
    	exit 1
    fi
    if [ -z "${K2HR3API_LOCAL_SVC_NAME}" ]; then
    	echo "[ERROR] ${PRGNAME} : K2HR3API_LOCAL_SVC_NAME environment is not specified."
    	exit 1
    fi
    if [ -z "${K2HR3API_LOCAL_PORT}" ]; then
    	echo "[ERROR] ${PRGNAME} : K2HR3API_LOCAL_PORT environment is not specified."
    	exit 1
    fi
    if [ -z "${K2HR3API_NP_BASE_HOSTNAME}" ]; then
    	echo "[ERROR] ${PRGNAME} : K2HR3API_NP_BASE_HOSTNAME environment is not specified."
    	exit 1
    fi
    if [ -z "${K2HR3API_NP_PORT}" ]; then
    	echo "[ERROR] ${PRGNAME} : K2HR3API_NP_PORT environment is not specified."
    	exit 1
    fi
    if [ -z "${K2HR3APP_NP_BASE_HOSTNAME}" ]; then
    	echo "[ERROR] ${PRGNAME} : K2HR3APP_NP_BASE_HOSTNAME environment is not specified."
    	exit 1
    fi
    if [ -z "${K2HR3APP_NP_PORT}" ]; then
    	echo "[ERROR] ${PRGNAME} : K2HR3APP_NP_PORT environment is not specified."
    	exit 1
    fi
    
    #----------------------------------------------------------
    # Setup OS_NAME
    #----------------------------------------------------------
    if [ ! -f /etc/os-release ]; then
    	echo "[ERROR] Not found /etc/os-release file."
    	exit 1
    fi
    OS_NAME=$(grep '^ID[[:space:]]*=[[:space:]]*' /etc/os-release | sed -e 's|^ID[[:space:]]*=[[:space:]]*||g' -e 's|^[[:space:]]*||g' -e 's|[[:space:]]*$||g' -e 's|"||g')
    
    if echo "${OS_NAME}" | grep -q -i "centos"; then
    	echo "[ERROR] Not support ${OS_NAME}."
    	exit 1
    fi
    
    #----------------------------------------------------------
    # Utility for ubuntu
    #----------------------------------------------------------
    IS_SETUP_APT_ENV=0
    
    setup_apt_envirnment()
    {
    	if [ "${IS_SETUP_APT_ENV}" -eq 1 ]; then
    		return 0
    	fi
    	if [ -n "${HTTP_PROXY}" ] || [ -n "${http_proxy}" ] || [ -n "${HTTPS_PROXY}" ] || [ -n "${https_proxy}" ]; then
    		if [ ! -f /etc/apt/apt.conf.d/00-aptproxy.conf ] || ! grep -q -e 'Acquire::http::Proxy' -e 'Acquire::https::Proxy' /etc/apt/apt.conf.d/00-aptproxy.conf; then
    			_FOUND_HTTP_PROXY=$(if [ -n "${HTTP_PROXY}" ]; then echo "${HTTP_PROXY}"; elif [ -n "${http_proxy}" ]; then echo "${http_proxy}"; else echo ''; fi)
    			_FOUND_HTTPS_PROXY=$(if [ -n "${HTTPS_PROXY}" ]; then echo "${HTTPS_PROXY}"; elif [ -n "${https_proxy}" ]; then echo "${https_proxy}"; else echo ''; fi)
    
    			if [ -n "${_FOUND_HTTP_PROXY}" ] && echo "${_FOUND_HTTP_PROXY}" | grep -q -v '://'; then
    				_FOUND_HTTP_PROXY="http://${_FOUND_HTTP_PROXY}"
    			fi
    			if [ -n "${_FOUND_HTTPS_PROXY}" ] && echo "${_FOUND_HTTPS_PROXY}" | grep -q -v '://'; then
    				_FOUND_HTTPS_PROXY="http://${_FOUND_HTTPS_PROXY}"
    			fi
    			if [ ! -d /etc/apt/apt.conf.d ]; then
    				mkdir -p /etc/apt/apt.conf.d
    			fi
    			{
    				if [ -n "${_FOUND_HTTP_PROXY}" ]; then
    					echo "Acquire::http::Proxy \"${_FOUND_HTTP_PROXY}\";"
    				fi
    				if [ -n "${_FOUND_HTTPS_PROXY}" ]; then
    					echo "Acquire::https::Proxy \"${_FOUND_HTTPS_PROXY}\";"
    				fi
    			} >> /etc/apt/apt.conf.d/00-aptproxy.conf
    		fi
    	fi
    	DEBIAN_FRONTEND=noninteractive
    	export DEBIAN_FRONTEND
    
    	IS_SETUP_APT_ENV=1
    
    	return 0
    }
    
    #----------------------------------------------------------
    # Check curl command and install
    #----------------------------------------------------------
    if ! CURL_COMMAND=$(command -v curl 2>/dev/null); then
    	if echo "${OS_NAME}" | grep -q -i "alpine"; then
    		if ! apk update -q --no-progress >/dev/null 2>&1 || ! apk add -q --no-progress --no-cache curl >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install curl."
    			exit 1
    		fi
    	elif echo "${OS_NAME}" | grep -q -i -e "ubuntu" -e "debian"; then
    		setup_apt_envirnment
    		if ! apt-get update -y -q -q >/dev/null 2>&1 || ! apt-get install -y curl >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install curl."
    			exit 1
    		fi
    	elif echo "${OS_NAME}" | grep -q -i -e "rocky" -e "fedora"; then
    		if ! dnf update -y --nobest --skip-broken -q >/dev/null 2>&1 || ! dnf install -y curl >/dev/null 2>&1; then
    			echo "[ERROR] Failed to install curl."
    			exit 1
    		fi
    	else
    		echo "[ERROR] Unknown OS type(${OS_NAME})."
    		exit 1
    	fi
    
    	if ! CURL_COMMAND=$(command -v curl 2>/dev/null); then
    		echo "[ERROR] Could not install curl for ${OS_NAME}."
    		exit 1
    	fi
    
    fi
    CURL_COMMAND=$(command -v curl 2>/dev/null)
    
    #----------------------------------------------------------
    # Check K2HR3 API
    #----------------------------------------------------------
    #
    # access to each pod directly
    # ex. https://pod-r3api-dbaask2hr3-0.svc-r3api-dbaask2hr3.default.svc.cluster.local:443/
    #
    while [ "${K2HR3API_COUNT}" -gt 0 ]; do
    	K2HR3API_COUNT=$((K2HR3API_COUNT - 1))
    	rm -f "${RESULT_CONTENTS_FILE}"
    
    	if ! RESULT_CODE=$("${CURL_COMMAND}" -s -S -w '%{http_code}' -o "${RESULT_CONTENTS_FILE}" -X GET https://"${K2HR3API_LOCAL_BASE_HOSTNAME}""${K2HR3API_COUNT}"."${K2HR3API_LOCAL_SVC_NAME}"."${K2HR3_NAMESPACE}"."${K2HR3_BASE_DOMAIN}":"${K2HR3API_LOCAL_PORT}"/ --insecure); then
    		echo "[ERROR] ${PRGNAME} : curl command is failed for ${K2HR3API_LOCAL_BASE_HOSTNAME}${K2HR3API_COUNT}.${K2HR3API_LOCAL_SVC_NAME}.${K2HR3_NAMESPACE}.${K2HR3_BASE_DOMAIN}:${K2HR3API_LOCAL_PORT}"
    		exit 1
    	fi
    	if [ -z "${RESULT_CODE}" ] || [ "${RESULT_CODE}" -ne 200 ]; then
    		echo "[ERROR] ${PRGNAME} : Got ${RESULT_CODE} http result code from ${K2HR3API_LOCAL_BASE_HOSTNAME}${K2HR3API_COUNT}.${K2HR3API_LOCAL_SVC_NAME}.${K2HR3_NAMESPACE}.${K2HR3_BASE_DOMAIN}:${K2HR3API_LOCAL_PORT}"
    		exit 1
    	fi
    
    	RESULT_RESPONSE=$(cat "${RESULT_CONTENTS_FILE}")
    	if [ -z "${RESULT_RESPONSE}" ] || [ "${RESULT_RESPONSE}" != "{\"version\":[\"v1\"]}" ]; then
    		echo "[ERROR] ${PRGNAME} : Got wrong contents( ${RESULT_RESPONSE} ) from ${K2HR3API_LOCAL_BASE_HOSTNAME}${K2HR3API_COUNT}.${K2HR3API_LOCAL_SVC_NAME}.${K2HR3_NAMESPACE}.${K2HR3_BASE_DOMAIN}:${K2HR3API_LOCAL_PORT}"
    		exit 1
    	fi
    done
    rm -f "${RESULT_CONTENTS_FILE}"
    
    #
    # access to NodePort
    # ex. https://np-r3api-dbaask2hr3.default.svc.cluster.local:8443/
    #
    if ! RESULT_CODE=$("${CURL_COMMAND}" -s -S -w '%{http_code}' -o "${RESULT_CONTENTS_FILE}" -X GET https://"${K2HR3API_NP_BASE_HOSTNAME}"."${K2HR3_NAMESPACE}"."${K2HR3_BASE_DOMAIN}":"${K2HR3API_NP_PORT}"/ --insecure); then
    	echo "[ERROR] ${PRGNAME} : curl command is failed for ${K2HR3API_NP_BASE_HOSTNAME}.${K2HR3_NAMESPACE}.${K2HR3_BASE_DOMAIN}:${K2HR3API_NP_PORT}"
    	exit 1
    fi
    if [ -z "${RESULT_CODE}" ] || [ "${RESULT_CODE}" -ne 200 ]; then
    	echo "[ERROR] ${PRGNAME} : Got ${RESULT_CODE} http result code from ${K2HR3API_NP_BASE_HOSTNAME}.${K2HR3_NAMESPACE}.${K2HR3_BASE_DOMAIN}:${K2HR3API_NP_PORT}"
    	exit 1
    fi
    
    RESULT_RESPONSE=$(cat "${RESULT_CONTENTS_FILE}")
    if [ -z "${RESULT_RESPONSE}" ] || [ "${RESULT_RESPONSE}" != "{\"version\":[\"v1\"]}" ]; then
    	echo "[ERROR] ${PRGNAME} : Got wrong contents( ${RESULT_RESPONSE} ) from ${K2HR3API_NP_BASE_HOSTNAME}:${K2HR3API_NP_PORT}"
    	exit 1
    fi
    rm -f "${RESULT_CONTENTS_FILE}"
    
    #----------------------------------------------------------
    # Check K2HR3 APP
    #----------------------------------------------------------
    #
    # access to NodePort
    # ex. https://np-r3app-dbaask2hr3.default.svc.cluster.local:8443/
    #
    if ! RESULT_CODE=$("${CURL_COMMAND}" -s -S -w '%{http_code}' -o "${RESULT_CONTENTS_FILE}" -X GET https://"${K2HR3APP_NP_BASE_HOSTNAME}"."${K2HR3_NAMESPACE}"."${K2HR3_BASE_DOMAIN}":"${K2HR3APP_NP_PORT}"/ --insecure); then
    	echo "[ERROR] ${PRGNAME} : curl command is failed for ${K2HR3APP_NP_BASE_HOSTNAME}.${K2HR3_NAMESPACE}.${K2HR3_BASE_DOMAIN}:${K2HR3APP_NP_PORT}"
    	exit 1
    fi
    if [ -z "${RESULT_CODE}" ] || [ "${RESULT_CODE}" -ne 200 ]; then
    	echo "[ERROR] ${PRGNAME} : Got ${RESULT_CODE} http result code from ${K2HR3APP_NP_BASE_HOSTNAME}.${K2HR3_NAMESPACE}.${K2HR3_BASE_DOMAIN}:${K2HR3APP_NP_PORT}"
    	exit 1
    fi
    
    RESULT_RESPONSE=$(cat "${RESULT_CONTENTS_FILE}")
    if [ -z "${RESULT_RESPONSE}" ]; then
    	echo "[ERROR] ${PRGNAME} : Got empty contents from ${K2HR3APP_NP_BASE_HOSTNAME}.${K2HR3_NAMESPACE}.${K2HR3_BASE_DOMAIN}:${K2HR3APP_NP_PORT}"
    	exit 1
    fi
    rm -f "${RESULT_CONTENTS_FILE}"
    
    #----------------------------------------------------------
    # Finish
    #----------------------------------------------------------
    echo "[SUCCEED] ${PRGNAME} : No problem to access to K2HR3 API/APP hosts."
    
    exit 0
    
    #
    # Local variables:
    # tab-width: 4
    # c-basic-offset: 4
    # End:
    # vim600: noexpandtab sw=4 ts=4 fdm=marker
    # vim<600: noexpandtab sw=4 ts=4
    #
    
  k2hr3-k2hdkc.ini.templ: |-
    #
    # K2HR3 Helm Chart
    #
    # Copyright 2022 Yahoo Japan Corporation.
    #
    # K2HR3 is K2hdkc based Resource and Roles and policy Rules, gathers 
    # common management information for the cloud.
    # K2HR3 can dynamically manage information as "who", "what", "operate".
    # These are stored as roles, resources, policies in K2hdkc, and the
    # client system can dynamically read and modify these information.
    #
    # For the full copyright and license information, please view
    # the license file that was distributed with this source code.
    #
    # AUTHOR:   Takeshi Nakatani
    # CREATE:   Wed Jan 19 2022
    # REVISION:
    #
    
    #
    # GLOBAL SECTION
    #
    [GLOBAL]
    FILEVERSION         = 1
    DATE                = %%CHMPX_DATE%%
    GROUP               = R3DKC
    MODE                = %%CHMPX_MODE%%
    CHMPXIDTYPE         = CUSTOM
    DELIVERMODE         = hash
    MAXCHMPX            = 32
    REPLICA             = 1
    MAXMQSERVER         = 16
    MAXMQCLIENT         = 16
    MQPERATTACH         = 4
    MAXQPERSERVERMQ     = 4
    MAXQPERCLIENTMQ     = 4
    MAXMQPERCLIENT      = 4
    MAXHISTLOG          = 0
    SELFCTLPORT         = %%CHMPX_SELFPORT%%
    RWTIMEOUT           = 10000
    RETRYCNT            = 500
    CONTIMEOUT          = 10000
    MQRWTIMEOUT         = 500
    MQRETRYCNT          = 10000
    MQACK				= no
    AUTOMERGE			= on
    DOMERGE             = on
    MERGETIMEOUT		= 0
    SOCKTHREADCNT		= 8
    MQTHREADCNT			= 8
    MAXSOCKPOOL			= 16
    SOCKPOOLTIMEOUT		= 0
    K2HFULLMAP          = on
    K2HMASKBIT          = 8
    K2HCMASKBIT         = 4
    K2HMAXELE           = 8
    %%CHMPX_SSL_SETTING%%
    
    #
    # K2HDKC SECTION
    #
    [K2HDKC]
    #RCVTIMEOUT			= 1000
    #SVRNODEINI			= <file path>
    #REPLCLUSTERINI		= <file path>
    #DTORTHREADCNT		= 1
    #DTORCTP			= path.so
    K2HTYPE				= file
    K2HFILE				= /var/lib/antpickax/k2hdkc/k2hdkc.k2h
    K2HFULLMAP			= on
    K2HINIT				= no
    K2HMASKBIT			= 8
    K2HCMASKBIT			= 4
    K2HMAXELE			= 16
    K2HPAGESIZE			= 128
    #PASSPHRASES		= <pass phrase>
    #PASSFILE			= <file path>
    #HISTORY			= on
    #EXPIRE				= 300
    #ATTRPLUGIN			= <file path>
    #MINTHREAD			= 1
    MAXTHREAD			= 20
    #REDUCETIME			= 30
    
    #
    # End of template, after this lines are added by the script
    # for server / slave nodes
    #
    
  k2hr3-api-production.json5: |-
    /*
    *
    * K2HR3 Helm Chart
    *
    * Copyright 2022 Yahoo Japan Corporation.
    *
    * K2HR3 is K2hdkc based Resource and Roles and policy Rules, gathers 
    * common management information for the cloud.
    * K2HR3 can dynamically manage information as "who", "what", "operate".
    * These are stored as roles, resources, policies in K2hdkc, and the
    * client system can dynamically read and modify these information.
    *
    * For the full copyright and license information, please view
    * the license file that was distributed with this source code.
    *
    * AUTHOR:   Takeshi Nakatani
    * CREATE:   Wed Jan 19 2022
    * REVISION:
    *
    */
    
    //--------------------------------------------------------------
    // Variable to be replaced( %%...%% )
    // 
    //	K2HR3_API_INI_FILENAME		ex) "slave.ini" or "nss_slave.ini"
    //	K2HR3_API_INTERNAL_HOST		ex) 192.168.0.1, svc-r3api.default.svc.cluster.local
    //	OIDC_ISSUER_URL				ex) https://..../dex
    //	OIDC_CLIENT_ID				ex) xxxxxxxxxxxxxxxxxxxx
    //	OIDC_USERNAME_KEY			ex) allow empty value
    //	K8S_API_URL					ex) https://kubernetes.default.svc
    //	K8S_CA_CERT					ex) /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
    //	K8S_SA_TOKEN				ex) /var/run/secrets/kubernetes.io/serviceaccount/token
    //
    //--------------------------------------------------------------
    {
    	'keystone': {
    		'type':			'k8soidc'
    	},
    
    	'k2hdkc': {
    		'config':			'/etc/antpickax/slave.ini',
    		'port':				8022
    	},
    
    	'corsips': [
    		'*'
    	],
    
    	'multiproc':			true,
    	'scheme':				'https',
    	'runuser':				'root',
    	'privatekey':			'/etc/antpickax/server.key',
    	'cert':					'/etc/antpickax/server.crt',
    	'ca':					'/etc/antpickax/ca.crt',
    
    	'userdata': {
    		'baseuri':			'https://svc-r3api-dummy.default.svc.cluster.local:443',
    		'cc_templ':			'config/k2hr3-cloud-config.txt.templ',
    		'script_templ':		'config/k2hr3-init.sh.templ',
    		'errscript_templ':	'config/k2hr3-init-error.sh.templ',
    		'algorithm':		'aes-256-cbc',
    		'passphrase':		'k2hr3_regpass'
    	},
    
    	'localtenants':		true,
    
    	'chkipconfig': {
    		'type':			'NoCheck',
    		'pendingsec':	864000,
    		'intervalms':	4320000,
    		'timeoutms':	5000
    	},
    
    	'k8soidc': {
    		'audience':		'dummy-oidc-clientid',
    		'issuer':		'https://localhost/dex',
    		'usernamekey':	'dummy:username',
    		'k8sapi_url':	'https://kubernetes.default.svc',
    		'k8s_ca_path':	'/var/run/secrets/kubernetes.io/serviceaccount/ca.crt',
    		'k8s_sa_token':	'/var/run/secrets/kubernetes.io/serviceaccount/token'
    	}
    }
    
    /*
    * Local variables:
    * tab-width: 4
    * c-basic-offset: 4
    * End:
    * vim600: noexpandtab sw=4 ts=4 fdm=marker
    * vim<600: noexpandtab sw=4 ts=4
    */
    
  k2hr3-app-production.json5: |-
    /*
    *
    * K2HR3 Helm Chart
    *
    * Copyright 2022 Yahoo Japan Corporation.
    *
    * K2HR3 is K2hdkc based Resource and Roles and policy Rules, gathers 
    * common management information for the cloud.
    * K2HR3 can dynamically manage information as "who", "what", "operate".
    * These are stored as roles, resources, policies in K2hdkc, and the
    * client system can dynamically read and modify these information.
    *
    * For the full copyright and license information, please view
    * the license file that was distributed with this source code.
    *
    * AUTHOR:   Takeshi Nakatani
    * CREATE:   Wed Jan 19 2022
    * REVISION:
    * 
    */
    
    //--------------------------------------------------------------
    // Variable to be replaced( %%...%% )
    // 
    //	K2HR3_APP_EXTERNAL_HOST		ex) 192.168.0.1, r3app.example.com
    //	K2HR3_APP_EXTERNAL_PORT		ex) 32443
    //	K2HR3_API_EXTERNAL_HOST		ex) 192.168.0.1, r3api.example.com
    //	K2HR3_API_EXTERNAL_PORT		ex) 32043
    //	OIDC_ISSUER_URL				ex) https://..../dex
    //	OIDC_CLIENT_SECRET			ex) xxxxxxxxxxxxxxxxxxxx
    //	OIDC_CLIENT_ID				ex) xxxxxxxxxxxxxxxxxxxx
    //	OIDC_USERNAME_KEY			ex) allow empty value
    //	OIDC_COOKIENAME				ex) cookie name(if empty, use id_token as default)
    //	OIDC_COOKIE_EXPIRE			ex) cookie expire(if empty, use 60 as default)
    //
    //--------------------------------------------------------------
    {
    	'scheme':				'https',
    	'port':					443,
    	'multiproc':			true,
    	'runuser':				'root',
    	'privatekey':			'/etc/antpickax/server.key',
    	'cert':					'/etc/antpickax/server.crt',
    	'ca':					'/etc/antpickax/ca.crt',
    	'uselocaltenant':		true,
    	'lang':					'ja',
    
    	'validator':			'userValidateOidc',
    	'validobj':				null,
    	'rejectUnauthorized':	true,
    	'lang':					'en',
    	'extrouter': {
    		'oidc': {
    			'name':						'oidc',
    			'path':						'/oidc',
    			'config': {
    				'debug':				true,
    				'logoutUrl':			'https://localhost:%%K2HR3_APP_EXTERNAL_PORT%%/oidc/logout',
    				'mainUrl':				'https://localhost:%%K2HR3_APP_EXTERNAL_PORT%%/',
    				'oidcDiscoveryUrl':		'https://localhost/dex',
    				'params': {
    					'client_secret':	'dummy-oidc-secret',
    					'client_id':		'dummy-oidc-clientid',
    					'redirectUrl':		'https://localhost:%%K2HR3_APP_EXTERNAL_PORT%%/oidc/login/cb',
    					'usernamekey':		'dummy:username',
    					'cookiename':		'id_token',
    					'cookieexpire':		'60'
    				},
    				'scope':				'openid profile email'
    			}
    		}
    	},
    
    	'apischeme':	'https',
    	'apihost':		'localhost',
    	'apiport':		%%K2HR3_API_EXTERNAL_PORT%%
    }
    
    /*
    * Local variables:
    * tab-width: 4
    * c-basic-offset: 4
    * End:
    * vim600: noexpandtab sw=4 ts=4 fdm=marker
    * vim<600: noexpandtab sw=4 ts=4
    */
---

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cr-r3api-dummy
rules:
- apiGroups: [""]
  resources: ["namespaces"]
  verbs: ["get", "list"]
---

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: crb-r3api-dummy
roleRef:
  kind: ClusterRole
  name: cr-r3api-dummy
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: ServiceAccount
  name: sa-r3api-dummy
  namespace: default
---

apiVersion: v1
kind: Service
metadata:
  name: np-r3api-dummy
spec:
  type: NodePort
  ports:
    - name: "k2hr3-api-port"
      protocol: "TCP"
      port: 8443
      targetPort: 443
      nodePort: 31443
  selector:
    app: r3api-dummy
---

apiVersion: v1
kind: Service
metadata:
  name: np-r3app-dummy
spec:
  type: NodePort
  ports:
    - name: "k2hr3-app-port"
      protocol: "TCP"
      port: 8443
      targetPort: 443
      nodePort: 32443
  selector:
    app: r3app-dummy
---

apiVersion: v1
kind: Service
metadata:
  name: svc-r3dkc-dummy
spec:
  type: ClusterIP
  clusterIP: None
  ports:
    - name: "chmpx-server-port"
      protocol: "TCP"
      port: 8020
      targetPort: 8020
    - name: "chmpx-server-control-port"
      protocol: "TCP"
      port: 8021
      targetPort: 8021
  selector:
    app: r3dkc-dummy
---

apiVersion: v1
kind: Service
metadata:
  name: svc-r3api-dummy
spec:
  type: ClusterIP
  clusterIP: None
  ports:
    - name: "chmpx-slave-control-port"
      protocol: "TCP"
      port: 8022
      targetPort: 8022
  selector:
    app: r3api-dummy
---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: pod-r3app-dummy
spec:
  replicas: 2
  selector:
    matchLabels:
      app: r3app-dummy
  template:
    metadata:
      labels:
        app: r3app-dummy
    spec:
      volumes:
        - name: antpickax-etc-volume
          emptyDir:
            medium: Memory
        - name: antpickax-var-run-volume
          emptyDir:
            medium: Memory
        - name: configmap-k2hr3-dummy
          configMap:
            name: configmap-k2hr3-dummy
            items:
              - key: k2hr3-app-init.sh
                path: k2hr3-app-init.sh
              - key: k2hr3-app-wrap.sh
                path: k2hr3-app-wrap.sh
              - key: k2hr3-setup-certificate.sh
                path: k2hr3-setup-certificate.sh
              - key: k2hr3-app-production.json5
                path: k2hr3-app-production.json5
        - name: secret-k2hr3-ca-dummy
          secret:
            secretName: secret-k2hr3-ca-dummy
      shareProcessNamespace: true
      initContainers:
        - name: init-r3app-dummy
          image: alpine:3.22
          command: ["/bin/sh"]
          args: ["/configmap/k2hr3-app-init.sh"]
          env:
            - name: HTTP_PROXY
              value: ""
            - name: HTTPS_PROXY
              value: ""
            - name: NO_PROXY
              value: ""
            - name: http_proxy
              value: ""
            - name: https_proxy
              value: ""
            - name: DEBIAN_FRONTEND
              value: "noninteractive"
            - name: USING_SERVICE_NAME
              value: "np-r3app-dummy"
            - name: ANTPICKAX_ETC_DIR
              value: "/etc/antpickax"
            - name: CERT_PERIOD_DAYS
              value: "1825"
            - name: SEC_CA_MOUNTPOINT
              value: "/secret-ca"
            - name: CERT_EXTERNAL_HOSTNAME
              value: "localhost"
          volumeMounts:
            - mountPath: /etc/antpickax
              name: antpickax-etc-volume
            - mountPath: /configmap
              name: configmap-k2hr3-dummy
              readOnly: true
            - mountPath: /secret-ca
              name: secret-k2hr3-ca-dummy
              readOnly: true
      containers:
        - name: container-r3app-dummy
          image: k2hr3-app:1.0.41
          env:
            - name: HTTP_PROXY
              value: ""
            - name: HTTPS_PROXY
              value: ""
            - name: NO_PROXY
              value: ""
            - name: http_proxy
              value: ""
            - name: https_proxy
              value: ""
            - name: DEBIAN_FRONTEND
              value: "noninteractive"
            - name: K2HR3_MANUAL_START
              value: "false"
            - name: K2HR3API_SERVICE_NAME
              value: "np-r3api-dummy"
            - name: K2HR3API_EXTERNAL_HOST
              value: "localhost"
            - name: K2HR3API_EXTERNAL_PORT
              value: "31443"
            - name: K2HR3APP_SERVICE_NAME
              value: "np-r3app-dummy"
            - name: K2HR3APP_EXTERNAL_HOST
              value: "localhost"
            - name: K2HR3APP_EXTERNAL_PORT
              value: "32443"
            - name: K2HR3APP_RUN_ON_MINIKUBE
              value: "true"
          volumeMounts:
            - mountPath: /etc/antpickax
              name: antpickax-etc-volume
            - mountPath: /var/run/antpickax
              name: antpickax-var-run-volume
            - mountPath: /configmap
              name: configmap-k2hr3-dummy
              readOnly: true
          command: ["/bin/sh"]
          args: ["/configmap/k2hr3-app-wrap.sh"]
---

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: pod-r3dkc-dummy
spec:
  podManagementPolicy: OrderedReady
  serviceName: svc-r3dkc-dummy
  replicas: 2
  selector:
    matchLabels:
      app: r3dkc-dummy
  template:
    metadata:
      labels:
        app: r3dkc-dummy
    spec:
      volumes:
        - name: antpickax-etc-volume
          emptyDir:
            medium: Memory
        - name: antpickax-var-lib-volume
          emptyDir:
            medium: Memory
        - name: antpickax-var-run-volume
          emptyDir:
            medium: Memory
        - name: configmap-k2hr3-dummy
          configMap:
            name: configmap-k2hr3-dummy
            items:
              - key: k2hr3-k2hdkc-serverproc-wrap.sh
                path: k2hr3-k2hdkc-serverproc-wrap.sh
              - key: k2hr3-k2hdkc-chmpxproc-wrap.sh
                path: k2hr3-k2hdkc-chmpxproc-wrap.sh
              - key: k2hr3-k2hdkc-ini-update.sh
                path: k2hr3-k2hdkc-ini-update.sh
              - key: k2hr3-setup-certificate.sh
                path: k2hr3-setup-certificate.sh
              - key: k2hr3-k2hdkc.ini.templ
                path: k2hr3-k2hdkc.ini.templ
        - name: secret-k2hr3-ca-dummy
          secret:
            secretName: secret-k2hr3-ca-dummy
      shareProcessNamespace: true
      initContainers:
        - name: init-r3dkc-dummy
          image: alpine:3.22
          command: ["/bin/sh"]
          args: ["/configmap/k2hr3-k2hdkc-ini-update.sh"]
          env:
            - name: HTTP_PROXY
              value: ""
            - name: HTTPS_PROXY
              value: ""
            - name: NO_PROXY
              value: ""
            - name: http_proxy
              value: ""
            - name: https_proxy
              value: ""
            - name: DEBIAN_FRONTEND
              value: "noninteractive"
            - name: CHMPX_INI_TEMPLATE_FILE
              value: "/configmap/k2hr3-k2hdkc.ini.templ"
            - name: CHMPX_INI_DIR
              value: "/etc/antpickax"
            - name: CHMPX_MODE
              value: "SERVER"
            - name: CHMPX_SERVER_PORT
              value: "8020"
            - name: CHMPX_SERVER_CTLPORT
              value: "8021"
            - name: CHMPX_SLAVE_CTLPORT
              value: "8022"
            - name: CHMPX_DEFAULT_DOMAIN
              value: "svc.cluster.local"
            - name: CHMPX_SERVER_COUNT
              value: "2"
            - name: CHMPX_SERVER_NAMEBASE
              value: "r3dkc-dummy"
            - name: CHMPX_SLAVE_COUNT
              value: "2"
            - name: CHMPX_SLAVE_NAMEBASE
              value: "r3api-dummy"
            - name: CHMPX_POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: CHMPX_SELF_HOSTNAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: CERT_PERIOD_DAYS
              value: "1825"
            - name: SEC_CA_MOUNTPOINT
              value: "/secret-ca"
          volumeMounts:
            - mountPath: /etc/antpickax
              name: antpickax-etc-volume
            - mountPath: /configmap
              name: configmap-k2hr3-dummy
              readOnly: true
            - mountPath: /secret-ca
              name: secret-k2hr3-ca-dummy
              readOnly: true
      containers:
        - name: container-r3dkc-dummy
          image: k2hdkc:1.0.17
          env:
            - name: HTTP_PROXY
              value: ""
            - name: HTTPS_PROXY
              value: ""
            - name: NO_PROXY
              value: ""
            - name: http_proxy
              value: ""
            - name: https_proxy
              value: ""
            - name: DEBIAN_FRONTEND
              value: "noninteractive"
          volumeMounts:
            - mountPath: /etc/antpickax
              name: antpickax-etc-volume
            - mountPath: /var/lib/antpickax
              name: antpickax-var-lib-volume
            - mountPath: /var/run/antpickax
              name: antpickax-var-run-volume
            - mountPath: /configmap
              name: configmap-k2hr3-dummy
              readOnly: true
          command: ["/bin/sh"]
          args: ["/configmap/k2hr3-k2hdkc-serverproc-wrap.sh", "server"]
        - name: sidecar-r3dkc-dummy
          image: chmpx:1.0.110
          env:
            - name: HTTP_PROXY
              value: ""
            - name: HTTPS_PROXY
              value: ""
            - name: NO_PROXY
              value: ""
            - name: http_proxy
              value: ""
            - name: https_proxy
              value: ""
            - name: DEBIAN_FRONTEND
              value: "noninteractive"
          volumeMounts:
            - mountPath: /etc/antpickax
              name: antpickax-etc-volume
            - mountPath: /var/lib/antpickax
              name: antpickax-var-lib-volume
            - mountPath: /var/run/antpickax
              name: antpickax-var-run-volume
            - mountPath: /configmap
              name: configmap-k2hr3-dummy
          command: ["/bin/sh"]
          args: ["/configmap/k2hr3-k2hdkc-chmpxproc-wrap.sh", "server"]
---

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: pod-r3api-dummy
spec:
  podManagementPolicy: OrderedReady
  serviceName: svc-r3api-dummy
  replicas: 2
  selector:
    matchLabels:
      app: r3api-dummy
  template:
    metadata:
      labels:
        app: r3api-dummy
    spec:
      serviceAccountName: sa-r3api-dummy
      volumes:
        - name: antpickax-etc-volume
          emptyDir:
            medium: Memory
        - name: antpickax-var-lib-volume
          emptyDir:
            medium: Memory
        - name: antpickax-var-run-volume
          emptyDir:
            medium: Memory
        - name: configmap-k2hr3-dummy
          configMap:
            name: configmap-k2hr3-dummy
            items:
              - key: k2hr3-k2hdkc-chmpxproc-wrap.sh
                path: k2hr3-k2hdkc-chmpxproc-wrap.sh
              - key: k2hr3-k2hdkc-ini-update.sh
                path: k2hr3-k2hdkc-ini-update.sh
              - key: k2hr3-k2hdkc.ini.templ
                path: k2hr3-k2hdkc.ini.templ
              - key: k2hr3-api-wrap.sh
                path: k2hr3-api-wrap.sh
              - key: k2hr3-setup-certificate.sh
                path: k2hr3-setup-certificate.sh
              - key: k2hr3-api-production.json5
                path: k2hr3-api-production.json5
        - name: secret-k2hr3-ca-dummy
          secret:
            secretName: secret-k2hr3-ca-dummy
      shareProcessNamespace: true
      initContainers:
        - name: init-r3api-dummy
          image: alpine:3.22
          command: ["/bin/sh"]
          args: ["/configmap/k2hr3-k2hdkc-ini-update.sh"]
          env:
            - name: HTTP_PROXY
              value: ""
            - name: HTTPS_PROXY
              value: ""
            - name: NO_PROXY
              value: ""
            - name: http_proxy
              value: ""
            - name: https_proxy
              value: ""
            - name: DEBIAN_FRONTEND
              value: "noninteractive"
            - name: USING_SERVICE_NAME
              value: "np-r3api-dummy"
            - name: CHMPX_INI_TEMPLATE_FILE
              value: "/configmap/k2hr3-k2hdkc.ini.templ"
            - name: CHMPX_INI_DIR
              value: "/etc/antpickax"
            - name: CHMPX_MODE
              value: "SLAVE"
            - name: CHMPX_SERVER_PORT
              value: "8020"
            - name: CHMPX_SERVER_CTLPORT
              value: "8021"
            - name: CHMPX_SLAVE_CTLPORT
              value: "8022"
            - name: CHMPX_DEFAULT_DOMAIN
              value: "svc.cluster.local"
            - name: CHMPX_SERVER_COUNT
              value: "2"
            - name: CHMPX_SERVER_NAMEBASE
              value: "r3dkc-dummy"
            - name: CHMPX_SLAVE_COUNT
              value: "2"
            - name: CHMPX_SLAVE_NAMEBASE
              value: "r3api-dummy"
            - name: CHMPX_POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: CHMPX_SELF_HOSTNAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: CERT_PERIOD_DAYS
              value: "1825"
            - name: SEC_CA_MOUNTPOINT
              value: "/secret-ca"
            - name: CERT_EXTERNAL_HOSTNAME
              value: "localhost"
          volumeMounts:
            - mountPath: /etc/antpickax
              name: antpickax-etc-volume
            - mountPath: /configmap
              name: configmap-k2hr3-dummy
              readOnly: true
            - mountPath: /secret-ca
              name: secret-k2hr3-ca-dummy
              readOnly: true
      containers:
        - name: container-r3api-dummy
          image: k2hr3-api:1.0.42
          env:
            - name: HTTP_PROXY
              value: ""
            - name: HTTPS_PROXY
              value: ""
            - name: NO_PROXY
              value: ""
            - name: http_proxy
              value: ""
            - name: https_proxy
              value: ""
            - name: DEBIAN_FRONTEND
              value: "noninteractive"
            - name: K2HR3_MANUAL_START
              value: "false"
          volumeMounts:
            - mountPath: /etc/antpickax
              name: antpickax-etc-volume
            - mountPath: /var/lib/antpickax
              name: antpickax-var-lib-volume
            - mountPath: /var/run/antpickax
              name: antpickax-var-run-volume
            - mountPath: /configmap
              name: configmap-k2hr3-dummy
              readOnly: true
          command: ["/bin/sh"]
          args: ["/configmap/k2hr3-api-wrap.sh"]
        - name: sidecar-r3api-dummy
          image: chmpx:1.0.110
          env:
            - name: HTTP_PROXY
              value: ""
            - name: HTTPS_PROXY
              value: ""
            - name: NO_PROXY
              value: ""
            - name: http_proxy
              value: ""
            - name: https_proxy
              value: ""
            - name: DEBIAN_FRONTEND
              value: "noninteractive"
          volumeMounts:
            - mountPath: /etc/antpickax
              name: antpickax-etc-volume
            - mountPath: /var/lib/antpickax
              name: antpickax-var-lib-volume
            - mountPath: /var/run/antpickax
              name: antpickax-var-run-volume
            - mountPath: /configmap
              name: configmap-k2hr3-dummy
          command: ["/bin/sh"]
          args: ["/configmap/k2hr3-k2hdkc-chmpxproc-wrap.sh", "slave"]
---

apiVersion: v1
kind: Pod
metadata:
  name: pod-r3-check-dummy
  annotations:
    "helm.sh/hook": test-success
    "helm.sh/hook-delete-policy": hook-succeeded
spec:
  volumes:
    - name: configmap-k2hr3-dummy
      configMap:
        name: configmap-k2hr3-dummy
        items:
          - key: k2hr3-check.sh
            path: k2hr3-check.sh
  containers:
    - name: checker
      image: alpine:3.22
      env:
      - name: K2HR3_NAMESPACE
        valueFrom:
          fieldRef:
            fieldPath: metadata.namespace
      - name: K2HR3_BASE_DOMAIN
        value: "svc.cluster.local"
      - name: K2HR3API_COUNT
        value: "2"
      - name: K2HR3API_LOCAL_BASE_HOSTNAME
        value: "pod-r3api-dummy-"
      - name: K2HR3API_LOCAL_SVC_NAME
        value: "svc-r3api-dummy"
      - name: K2HR3API_LOCAL_PORT
        value: "443"
      - name: K2HR3API_NP_BASE_HOSTNAME
        value: "np-r3api-dummy"
      - name: K2HR3API_NP_PORT
        value: "8443"
      - name: K2HR3APP_NP_BASE_HOSTNAME
        value: "np-r3app-dummy"
      - name: K2HR3APP_NP_PORT
        value: "8443"
      volumeMounts:
        - mountPath: /configmap
          name: configmap-k2hr3-dummy
          readOnly: true
      command: ["/bin/sh"]
      args: ["/configmap/k2hr3-check.sh"]
  restartPolicy: Never
